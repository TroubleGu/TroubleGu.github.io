<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript</title>
      <link href="/2022/10/29/JS/"/>
      <url>/2022/10/29/JS/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript以下内容简称JS"><a href="#JavaScript以下内容简称JS" class="headerlink" title="JavaScript以下内容简称JS"></a>JavaScript以下内容简称JS</h1><p>JS是一种运行在JS解释器或者独立引擎上的，单线程、弱类型、解释性的脚本语言。</p><p>单线程：同一时间内，只能做一件事。</p><p>弱类型：声明变量时不用强制规定变量的数据类型。</p><p>解释性：解释一句，执行一句，效率低但跨平台性好。</p><h2 id="JS的三大组成部分"><a href="#JS的三大组成部分" class="headerlink" title="JS的三大组成部分"></a>JS的三大组成部分</h2><p>ECMAScript：JS的规范</p><p>DOM:DOM是一套操作HTML标签的API（接口&#x2F;方法&#x2F;属性）</p><p>BOM：是一套操作浏览器的API（接口&#x2F;方法&#x2F;属性）全称Browser Object Model 浏览器对象模型，浏览器对象模型提供了独立与内容的、可以与浏览器窗口进行互动的对象结构，BOM由多个对象构成，其中代表浏览器窗口的window对象是BOM的顶层对象，其他对象都是该对象的子对象。</p><h2 id="JS的引入方式"><a href="#JS的引入方式" class="headerlink" title="JS的引入方式"></a>JS的引入方式</h2><p>行内式：写在标签内的js代码 如：<code>&lt;div onclick=&quot; &quot;&gt;</code></p><p>外链式：使用script标签的src属性来引入外部的JS文件。</p><p>内嵌式：写在HTML文件里面，script标签里面的JS代码。</p><h2 id="JS解释器"><a href="#JS解释器" class="headerlink" title="JS解释器"></a>JS解释器</h2><p>JS解释器就是浏览器的内核<br>现在的主流浏览器以及内核如下：</p><ol><li>IE浏览器：Trident</li><li>chrome谷歌浏览器：Blink</li><li>FireFox火狐浏览器：Gecko</li><li>Opera欧朋浏览器：Blink</li><li>Safari苹果的浏览器：Webkit</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的作用：用来存储数据 </p><p>变量的初始化：变量的声明和赋值</p><h3 id="变量的声明相关操作"><a href="#变量的声明相关操作" class="headerlink" title="变量的声明相关操作"></a>变量的声明相关操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a; </span><br><span class="line">a = 10; </span><br><span class="line">a = 12; </span><br><span class="line">var a;</span><br></pre></td></tr></table></figure><p>1.变量声明：<code>var a;</code></p><p>2.变量赋值：<code>a = 10;</code></p><p>3.变量的重新赋值 <code>a = 12;</code></p><p>​3.1.先把内存中原值给销毁掉</p><p>​3.2.把新的值存入变量</p><p>4.变量的重新声明</p><p>​4.1.先把内存中原变量所开辟的内存空间销毁</p><p>​4.2.再在内存中开辟新的内存空间</p><p>5.变量的批量声明和赋值，每个变量用“ ， ”（逗号）隔开，最后必须使用分号结尾:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a=12,b=23,c=23,d=24,e=30;</span><br></pre></td></tr></table></figure><p>6.把一个变量的值赋值给另一个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var num1=12;</span><br><span class="line"></span><br><span class="line">var num2=num1;</span><br></pre></td></tr></table></figure><h3 id="变量的命名规则和规范"><a href="#变量的命名规则和规范" class="headerlink" title="变量的命名规则和规范"></a>变量的命名规则和规范</h3><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>1.变量名使用 <strong>_</strong> <strong>$</strong> 或者字母开头, 变量里面可以包括 <strong>_</strong> $ 字母 数字</p><p>2.变量必须声明后才能使用, 否则就会报错</p><p>3.不能使用js里面的关键字和保留字</p><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><p>1.最好使用英语单词来命名</p><p>2.驼峰命名法：第一个单词首字母小写，后面的单词首字母大写</p><p>3.直接量：计算机可以直接识别的数据，符合JS数据类型的数据。</p><h2 id="JS基础的五句话"><a href="#JS基础的五句话" class="headerlink" title="JS基础的五句话"></a>JS基础的五句话</h2><p>1.alert(“ “); 在页面弹出一个提示框</p><p>2.prompt(“ “); 在页面弹出一个输入框</p><p>3.console.log(“ “); 在控制台打印数据</p><p>4.confirm(“ “); 弹出确认框，默认有确认取消按钮</p><p>5.document.write(“ “); 动态地向页面添加内容</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>数字类型 (number 类型) : 数学上一切的数字 0 1 -1 3.14</p><p>Namber.Max_ :最大值<br>Namber.Min_VALUE：最小值<br>Infinity：正无穷<br>-Infinity: 负无穷<br>NaN:（Not A Number）是一种特殊的数字数据类型，数学运算错误的结果：</p><p>​1.他是数字类型中一个特殊的值 是数学计算错误得出的结果</p><p>​2.NaN不等于任何数值, 包括他自己</p><p>​3.NaN与任何数字进行计算 得到的都是NaN</p><p>​4.检测一个数据是不是NaN ： isNaN(数据)</p><h5 id="转换成number类型"><a href="#转换成number类型" class="headerlink" title="转换成number类型"></a>转换成number类型</h5><p>1.parseInt() 把其他数据类型转换成整数类型 偏向于转换字符串</p><p>特点 :<br>(1) 从左到右解析,遇到非数字字符, 就停止解析, 输出已经解析出的数字<br>(2) 如果第一字符就是非数字字符, 就无法转换, 得到NaN</p><p>2.parseFloat() 把其他数据类型转换成小数，与parseInt特点一样, 唯一的区别, 就是可以解析小数</p><p>3.Number() 把其他数据类型转换成数字<br>特点<br>(1) 可以把其他数据类型转换成数字类型, 偏向于转布尔类型的数据<br>(2) 如果转换的数据里面有任意一个是非数字字符(小数点除外), 那么得到的结果就是NaN<br>(3) 注意undefined 转换成数字, 是NaN null 是0<br>(4) 转布尔类型 true 是1 false是0</p><p>4.在数据前面加 +<br>特点 :<br>跟Number()转换的原理一样, 特点也一样<br>把+ 当做数学里面的正负号来用<br>在我们算术运算符里面, 运算符两边的操作数必须是数字</p><h5 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h5><p>自增自减，算数运算符（除+作为字符串连接符以外）两边必须是数字才能计算</p><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>布尔类型（boolean类型）：true false 表示的是事物的对立面 对错</p><h5 id="转换成布尔类型"><a href="#转换成布尔类型" class="headerlink" title="转换成布尔类型"></a>转换成布尔类型</h5><ol><li>Boolean()</li><li>转换成false的8种情况，（其他都是true）：0，-0，null，NaN,undefined,””,false，document.all</li></ol><h5 id="隐式转换-1"><a href="#隐式转换-1" class="headerlink" title="隐式转换"></a>隐式转换</h5><p>！ 逻辑非的操作必须是布尔类型的，计算机自动转换</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串类型（String类型）：js里面一切以双引号、单引号包裹的内容就是字符串类型</p><h5 id="转换成String类型"><a href="#转换成String类型" class="headerlink" title="转换成String类型"></a>转换成String类型</h5><ol><li>其他数据类型转换成字符串（String类型）：String(变量名或者数据)<br>可以转换undefined和null</li><li>变量名.toString()<br>不可以转换undefined和null<br>转换成数字类型：</li><li>数据+”” 在数据后面加一个空字符串就可以实现转换</li></ol><h5 id="隐式转换-2"><a href="#隐式转换-2" class="headerlink" title="隐式转换"></a>隐式转换</h5><p>转换成字符串：+ 字符串连接符，运算符两边，只要有一边是字符串，那么就会把另外一边转成字符串进行拼接</p><p><strong>注意点：</strong></p><p><strong>（1）在字符串里面包裹字符串，要用不同的引号</strong><br><strong>（2）不能单引号和双引号混合使用</strong><br><strong>（3）要注意区分变量名和字符串</strong></p><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>undefined 我们的变量声明之后 未赋值, js给变量赋的一个初始值 它是一种特殊的数据类型 他表示值为空</p><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>null 表示的值为空 它是一种特殊的对象 也成Null类型 <strong>必须人为的赋值给某个变量（与undefined的区别）</strong></p><h3 id="基本数据检测"><a href="#基本数据检测" class="headerlink" title="基本数据检测"></a>基本数据检测</h3><p> typeof 数据;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum=10;</span><br><span class="line"></span><br><span class="line">console.log(typeof sum);</span><br></pre></td></tr></table></figure><p> typeof ();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum=10;</span><br><span class="line"></span><br><span class="line">console.log(typeof(sum));</span><br></pre></td></tr></table></figure><h4 id="两种写法的区别"><a href="#两种写法的区别" class="headerlink" title="两种写法的区别"></a>两种写法的区别</h4><p>第二种写法有（）有一个运算符的优先级问题，（）运算符的优先级</p><p>比typeof高 所以优先计算括号里面的内容 再进行判断类型。</p><p>解析：</p><p><code>typeof (18-&#39;aaa&#39;)</code>中，<br> () 运算符优先度比 typeof 高，所以 (18-‘aaa’) 内优先计算得出 typeof(NaN) ，<br> 然后进行typeof运算判断类型，结果是 <em>“number”</em> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof (18-&#x27;aaa&#x27;)= typeof(NaN) = &quot;number&quot;</span><br></pre></td></tr></table></figure><p><code>typeof 18-&#39;aaa</code>‘中，<br> <em>typeof</em> 优先级比 <em>-</em> 高,所以先进行 <em>typeof 18</em> 运算，返回一个“number”，<br> 此时运算式就变成了 <em>“number”-“aaa”</em> ,结果就是个 <em>NaN</em> .</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof 18-&#x27;aaa&#x27; = (typeof 18)-&#x27;aaa&#x27; = “number”-“aaa” = NaN</span><br></pre></td></tr></table></figure><h4 id="typeof返回的数据"><a href="#typeof返回的数据" class="headerlink" title="typeof返回的数据"></a>typeof返回的数据</h4><p>typeof返回的数据有：<br>number、string、undefined、object、boolean、function</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象是属性与方法的集合，以键值对的方式书写</p><p>将一个事物的具体的特征和行为集中定义在一个对象中</p><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><h6 id="数组的三要素"><a href="#数组的三要素" class="headerlink" title="数组的三要素"></a>数组的三要素</h6><p><strong>索引 ：</strong>记录每个元素在数组中的位置<br><strong>元素 :</strong> 数组中存储的值<br><strong>数组长度 :</strong> 记录数组中的元素个数</p><p>​<strong>获取数组长度</strong> ：数组名.length 获取到的是一个number类型的数</p><p>​<strong>修改数组的长度</strong>： 会改变数组里面元素的数量 数组名.length &#x3D; 值; 这就相当于只保留对应数量的元素</p><p>​<strong>删除数组最后一个值</strong> : 数组名.length–, 数组长度减1, 相当于删除最后一个元素</p><h6 id="数组的声明方式"><a href="#数组的声明方式" class="headerlink" title="数组的声明方式"></a>数组的声明方式</h6><p><strong>var 数组名 &#x3D; [元素1, 元素2, …];(最常用)</strong></p><p><strong>var 数组名 &#x3D; new Array(元素1, 元素2, …);</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr=[10,20,30]; </span><br><span class="line">var newarr=new Array(10,20,30);</span><br></pre></td></tr></table></figure><h6 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a>数组的赋值</h6><p>数组名[索引] &#x3D; 值;</p><p>如果下标在最大下标范围内 : 就是修改数组元素的值<br>如果下标超过最大下标 : 那么就是给数组增加值,<br>如果要给数组最后加一个值 : 数组名[数组名.length] &#x3D; 值</p><h6 id="数组的取值"><a href="#数组的取值" class="headerlink" title="数组的取值"></a>数组的取值</h6><p>数组名[下标] 取值从下标0开始</p><p>取数组最后一个元素 : 数组名[数组名.length - 1];<br>下标在最大下标范围内, 获取数组元素<br>取值超过了最大下标, 获取到的元素是undefined</p><h6 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h6><p>获取数组中的每一个元素, 就是数组遍历</p><p>用for循环来遍历</p><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var arr=[10,10,20,50,20,80,60];</span><br><span class="line">for(var i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">var lg=false;//假设数组没有交换</span><br><span class="line">for(var j=0;j&lt;(arr.length-1)-i;j++)&#123;</span><br><span class="line">if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">var temp;</span><br><span class="line">var lg=true;</span><br><span class="line">temp=arr[j];</span><br><span class="line">arr[j]=arr[j+1];</span><br><span class="line">arr[j+1]=temp;</span><br><span class="line">&#125;</span><br><span class="line">if(!lg)&#123;//数组已经有序</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">document.write(arr);]()</span><br></pre></td></tr></table></figure><h6 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h6><p>开关思想去重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var arr=[10,10,20,50,20,80,60];</span><br><span class="line">var newArr=[];//声明一个空数组</span><br><span class="line">for(var i=0;i&lt;arr.length;i++)&#123;     //遍历原数组每个元素</span><br><span class="line">var isAdd=true;      //假设为真(声明一个开关)</span><br><span class="line">//判断原数组中的指定元素与新数组里面的元素是否相等</span><br><span class="line">for(var j=0;j&lt;newArr.length;j++)&#123;</span><br><span class="line">if(arr[i]==newArr[j])&#123;</span><br><span class="line">isAdd=false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//根据开关状态，来判断是否将元素添加到新数组中</span><br><span class="line">if(isAdd)&#123;</span><br><span class="line">newArr[newArr.length]=arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(newArr);</span><br></pre></td></tr></table></figure><h6 id="数组的API"><a href="#数组的API" class="headerlink" title="数组的API"></a>数组的API</h6><p>添加</p><p>1.push()方法 : 将一个或多个元素添加到数组的末尾<br>参数 : 可以是一个, 可以是多个, 表示向数组里面添加元素 参数可以不填, 但是一般默认, 第一个参数必填<br>返回值 : 将指定的值添加到数组后的新数组长度<br>特点 : 直接改变原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, 30]; </span><br><span class="line">var res = arr.push(50, 60);        </span><br><span class="line">console.log(res);        </span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p>2.unshift() : 将一个或多个元素添加到数组的开头<br>参数 : 可以是一个, 可以是多个, 表示向数组里面添加元素 参数可以不填, 但是一般默认, 第一个参数必填<br>返回值 : 将指定的值添加到数组后的新数组长度<br>特点 : 直接改变原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.unshift(50, 60); </span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p>删除</p><p>1 pop() : 删除数组中的最后一个元素<br>参数 : 没有参数, 因为指定的删除最后一个<br>返回值 : 返回删除的那个元素的值<br>特点 : 改变了原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.pop());</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p>2.shift() : 删除数组中的第一个元素<br>参数 : 没有参数, 因为指定的删除第一个<br>返回值 : 返回删除的那个元素的值<br>特点 : 改变了原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.shift());</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p>拼接</p><p>concat() : 用于合并两个或多个数组<br>参数 : 可以是单个或多个元素, 也可以是一个或多个数组, 也可以混合使用<br>返回值 : 返回拼接后的数组<br>特点 : 不改变原数组<br>注意点 : 虽然传递的参数是数组, 但是操作的是数组里面的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [90, 80, 70];       </span><br><span class="line">console.log( arr.concat(arr1));       console.log(arr.concat(80, 90, arr1));       console.log(arr);</span><br></pre></td></tr></table></figure><p>截取</p><p>1.slice(参数1, 参数2) 截取数组 从参数1开始截, 截到参数2, 但是不包括参数2<br>参数 : 两个参数 参数1 : 截取的起始下标 参数2 : 截取的结束下标(不包括在内)<br>返回值 : 返回的是截取到的元素组成的数组<br>特点 : 不改变原数组<br>注意 : 如果给了两个参数, 而且都是整数 常规用法<br>如果只给了一个参数, 那么这个参数就是开始截取得起始下标<br>如果参数是负数, (通俗的说, 就是倒着数) 截取下标为 arr.length + 负参数<br>如果不给参数 就是截取全部, 相当于赋值这个数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.slice(1, 2));  </span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p>2.splice() 修改, 添加, 删除一个数组中的某各项<br>参数 : 参数1 截取的起始下标<br>参数2 截取的元素个数<br>参数3到参数n : 表示替换或者添加的元素<br>返回值 : 截取的元素组成的新数组<br>特点 : 直接修改原数组<br>注意点 :<br>如果没有参数 返回值是空, 原数组不变<br>如果只有一个参数 这个参数表示截取的数组起始下标 它的用法和slice只有一个参数的效果是一样的, 返回值一样, 但是原数组发生了变化<br>如果只有两个参数 第一个参数是截取的数组起始下标 参数2 截取个数 这个是删除数组元素<br>如果有三个及以上参数 如果第二个参数值为0, 那么就表示添加新元素, 如果不为0, 表示删除对应个数的元素， 将新元素替换上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.splice(1, 2)); // [20, 30]</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p>查找</p><p>indexOf(参数1, 参数2);<br>参数 : 参数1 : 是需要查找的数组元素<br>参数2 : 查找数组的起始下标(索引)<br>返回值 : 查找到了对应元素, 返回查找到的第一个元素所对应的下标<br>如果没有查找到 返回-1<br>语法解析 : 该方法是从头到尾检索数组元素, 看看是否是否能查找到对应元素, 如果查找到了, 返回找到的第一个元素对应的下标(是在没有定义第二个参数的情况下),<br>如果有第二个参数, 就从参数2对应的位置开始检索元素, 返回找到的第一个元素对应的下标<br>如果没有找到 返回-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.indexOf(30));  </span><br><span class="line">console.log(arr.indexOf(30, 3));</span><br></pre></td></tr></table></figure><p>数组转成字符串</p><p>1.join() 该方法是使用指定的符号把各个数组元素连接成字符串<br>参数 : 指定的符号, 用来连接数组各元素, 默认是逗号<br>返回值 : 拼接后的字符串,<br>特点 : 不改变原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.join());</span><br></pre></td></tr></table></figure><p>2.toString() 作用和不传参数时的join一样 默认使用逗号隔开</p><p>改变原数组的方法 </p><p><code>push()</code></p><p><code>pop()</code> </p><p><code>unshift()</code> </p><p><code>shift()</code> </p><p><code>splice()</code> </p><p><code>reverse()</code> </p><p><code>sort()</code></p><p>不改变原数组的方法</p><p><code>concat()</code>   </p><p><code>slice()</code>   </p><p><code>indexOf()</code> </p><p><code>join()</code></p><h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>二维数组其实本质上就是有点特殊的一维数组，一维数组里面的元素是数据，而二维数组里面的元素是数组。</p><h6 id="二维数组的声明"><a href="#二维数组的声明" class="headerlink" title="二维数组的声明"></a>二维数组的声明</h6><p>方法1.<code>var a = [ [ 1,2 ], [ 3,4 ] ];</code></p><p>方法2.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array( new Array(1,2), new Array(3,4) );</span><br></pre></td></tr></table></figure><p>方法3.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array();//先声明一维数组</span><br><span class="line">    for(var i=0;i&lt;5;i++) &#123;</span><br><span class="line">    a[i] = new Array(i);//再声明二维数组</span><br><span class="line">    for(var j=0;j&lt;5;j++) &#123;</span><br><span class="line">    a[i][j] = i;//赋值</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="遍历二维数组"><a href="#遍历二维数组" class="headerlink" title="遍历二维数组"></a>遍历二维数组</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;a.length;i++) &#123;</span><br><span class="line">for(var j=0;j&lt;a[i].length;j++) &#123;</span><br><span class="line">console.log( a[i][j] );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h5><p>1.Math.abs() 求某个数的绝对值</p><p><code>var num =  -88;    console.log(Math.abs(num));</code></p><p>2.Math.round() 四舍五入</p><p><code>var num = 5.66;    console.log(Math.round(num));</code></p><p>3.Math.max() 求最大值</p><p> <code>console.log( Math.max(23, 25, 42));</code></p><p>4.Math.min() 求最小值</p><p><code>console.log( Math.min(23, 25, 42));</code></p><p>5.Math.random() 生成0-1之间的随机数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> var number1 = Math.random()</span><br><span class="line"></span><br><span class="line">console.log(number1);</span><br><span class="line"></span><br><span class="line">var number2 = Math.random() * 100 *</span><br><span class="line"></span><br><span class="line">//生成0-100之间的随机数*</span><br><span class="line"></span><br><span class="line">console.log(number2);</span><br></pre></td></tr></table></figure><p>6.底板函数 Math.floor() 向下取整</p><p><code>console.log(Math.floor(number1));</code></p><p>7.天花板函数 Math.ceil() 向上取整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`console.log(Math.ceil(number1));    </span><br><span class="line"></span><br><span class="line">var num1 = -5.23;    </span><br><span class="line"></span><br><span class="line">console.log(Math.ceil(num1));</span><br></pre></td></tr></table></figure><p>8.Math.PI 常量 必须使用Math去调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*//计算圆的面积*</span><br><span class="line"></span><br><span class="line">console.log(Math.PI);</span><br><span class="line"></span><br><span class="line">var r = 23;</span><br><span class="line"></span><br><span class="line">console.log(Math.PI * r * r);</span><br></pre></td></tr></table></figure><p>9.Math.E 自然对数e</p><p> <code>console.log(Math.E);</code></p><p>10.Math.pow(x, y) 幂运算：x的y次方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.pow(10, 3)); *//圆的面积：*</span><br><span class="line"></span><br><span class="line">var sqa = Math.PI * Math.pow(r, 2);    console.log(sqa);</span><br></pre></td></tr></table></figure><p>11.Math.sqrt() 开平方</p><p><code>var num=9 console.log(Math.sqrt(num));</code></p><h5 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h5><h6 id="创建日期对象"><a href="#创建日期对象" class="headerlink" title="创建日期对象"></a>创建日期对象</h6><p> 1.var 变量名 &#x3D; new Date(“日期字符串”);</p><ol start="2"><li>可以传入七个参数  分别是 年月日 时分秒 毫秒  参数至少要传2个</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> var date = new Date(2018, 12);</span><br><span class="line">console.log(date);</span><br></pre></td></tr></table></figure><p> 3, date对象中 创建时只传入一个参数   这个参数表示的是 毫秒数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date(2018);  // Thu Jan 01 1970 08:00:02 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(date);</span><br></pre></td></tr></table></figure><h6 id="日期字符串"><a href="#日期字符串" class="headerlink" title="日期字符串"></a>日期字符串</h6><p><strong>ISO</strong> : (国际标准) “2020-01-24” 日期和具体的时分秒之间用T隔开 “2020-01-24T12:00:00Z”,</p><p><strong>短日期</strong> : “01&#x2F;19&#x2F;2020” “2020&#x2F;01&#x2F;24” 也可以接具体的时分秒 中间使用空格隔开 注意 : 不要把日期写在最前面</p><p><strong>长日期</strong> : “Wed Jan 24 2020” 这种格式顺序可以随便写 也可以加时分秒 加空格隔开</p><p><strong>完整日期</strong> : 就是各月份 星期的英文全拼</p><p><strong>时间戳</strong> : 指的是1970年1月1日00:00:00 到某个指定的时间点的秒数</p><p><strong>js里面运算数据</strong> : 是1970年1月1日00:00:00 到某个指定的时间点的毫秒数</p><h6 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a><strong>获取时间</strong></h6><p><strong>getFullYear() 获取年份 返回的是一个四位数的年份</strong></p><p> <code>console.log(date.getFullYear());</code></p><p><strong>getMonth() 获取月份 注意 : js里面使用0-11表示1到12月份 所以我们获取到的月份加1</strong></p><p><code>console.log(date.getMonth());</code></p><p><strong>getDate() 获取当前日期 注意 1到31表示日期</strong></p><p><code>console.log(date.getDate());</code></p><p><strong>getDay() 获取当前日期的星期数 注意 : 使用0-6表示周日到周六 在国外 周日是第一天</strong></p><p><code>console.log(date.getDay());</code></p><p><strong>getHours() 获取当前的小时数</strong></p><p><code>console.log(date.getHours());</code></p><p><strong>getMinutes() 获取当前的分钟数</strong></p><p><code>console.log(date.getMinutes());</code></p><p><strong>getSeconds() 获取当前秒数</strong></p><p><code>console.log(date.getSeconds());</code></p><p><strong>getTime() 获取的是从1970年1月1日 00:00:00到现在的毫秒数</strong></p><p><code>console.log(date.getTime());</code></p><h6 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h6><p><strong>setFullYear() 返回值 从1970年1月1日到设置日期之间的毫秒数</strong><br>但是原本的日期对象发生了变化<br>注意点 : 月份是0 - 11表示1到12月份<br>参数 : 第一个参数默认必填, 但是后面可以接月, 日</p><p><code>console.log(date.setFullYear(2018)); console.log(date);</code></p><p><strong>setMonth() 设置的月份加1 才是真实的月份</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(date.setMonth(9));</span><br><span class="line">console.log(date);</span><br></pre></td></tr></table></figure><p><strong>setHours()获取当前小时数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date.setHours(12); // 小时的范围是 0 到23</span><br></pre></td></tr></table></figure><p><strong>setMinutes()获取当前分钟数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date.setMinutes(56);  *// 分钟的范围是0 到59*</span><br></pre></td></tr></table></figure><p><strong>setSeconds(23)获取当前秒数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date.setSeconds(23);</span><br></pre></td></tr></table></figure><h6 id="将日期对象转换成字符串"><a href="#将日期对象转换成字符串" class="headerlink" title="将日期对象转换成字符串"></a>将日期对象转换成字符串</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(date.toString());  </span><br></pre></td></tr></table></figure><p>转换成本地日期字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(date.toLocaleString()); </span><br></pre></td></tr></table></figure><p>把日期转换成本地日期字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(date.toLocaleDateString());  </span><br></pre></td></tr></table></figure><p>把时间转换成日期字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(date.toLocaleTimeString()); </span><br></pre></td></tr></table></figure><h6 id="日期的计算"><a href="#日期的计算" class="headerlink" title="日期的计算"></a>日期的计算</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var date1 = new Date(2019, 5, 12, 5, 30, 00);    var date2 = new Date(2019, 5, 13);</span><br></pre></td></tr></table></figure><p>1.可以直接两个日期对象直接相减 js内部自动转换成从1970年1月1日到指定时间的毫秒数进行相减</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dateSub = date1 - date2;</span><br><span class="line">console.log(Math.abs(dateSub)/(1000 * 60 * 60 * 24));</span><br></pre></td></tr></table></figure><p>2.计算相应的时间, 做相应的计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date1.setHours( date1.getHours() + 12);</span><br><span class="line">console.log(date1);</span><br><span class="line">date1.setMonth(date1.getMonth() + 1);</span><br></pre></td></tr></table></figure><h4 id="对象的声明"><a href="#对象的声明" class="headerlink" title="对象的声明"></a>对象的声明</h4><p>声明方式：</p><p>方法1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123; &#125;;</span><br><span class="line"></span><br><span class="line">var obj=&#123;</span><br><span class="line">name:&quot;小明&quot;,</span><br><span class="line">age:12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj=newObject( );</span><br><span class="line"></span><br><span class="line">var obj=newObject();</span><br><span class="line">obj.name=&quot;小明&quot;;</span><br><span class="line">obj.age=12;</span><br></pre></td></tr></table></figure><h4 id="对象的赋值"><a href="#对象的赋值" class="headerlink" title="对象的赋值"></a>对象的赋值</h4><p>1.对象名 . 属性名&#x3D;值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj=newObject();</span><br><span class="line">obj.name=&quot;小明&quot;;</span><br><span class="line">obj.age=12;</span><br></pre></td></tr></table></figure><p>2.属性名：值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;</span><br><span class="line">name:&quot;小明&quot;,</span><br><span class="line">age:12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的取值：<br>当没有这个属性时返回undefined<br>1.对象名 . 属性名</p><p> <code>obj.name</code></p><p>2.对象名[“属性名”]<br>[ ]里面属性名要有引号，没有引号就只是单纯的变量。</p><p><code>obj[&quot;name&quot;]</code></p><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>谁调用，就指向谁（在ES5中）<br>首先，this总是返回一个对象，简单说，就是返回属性或方法“当前”所在的对象。</p><p><code>this.property</code></p><p>上面代码中，this就代表property属性当前所在的对象。</p><p>下面是一个实际的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: &#x27;张三&#x27;,</span><br><span class="line">  describe: function () &#123;</span><br><span class="line">    return &#x27;姓名：&#x27;+ this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.describe()</span><br><span class="line">// &quot;姓名：张三&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，this.name表示describe方法所在的当前对象的name属性。调用person.describe方法时，describe方法所在的当前对象是person，所以就是调用person.name。</p><p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var A = &#123;</span><br><span class="line">  name: &#x27;张三&#x27;,</span><br><span class="line">  describe: function () &#123;</span><br><span class="line">    return &#x27;姓名：&#x27;+ this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = &#123;</span><br><span class="line">  name: &#x27;李四&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.describe = A.describe;</span><br><span class="line">B.describe()</span><br><span class="line">// &quot;姓名：李四&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。</p><p>稍稍重构这个例子，this的动态指向就能看得更清楚。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  return &#x27;姓名：&#x27;+ this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var A = &#123;</span><br><span class="line">  name: &#x27;张三&#x27;,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = &#123;</span><br><span class="line">  name: &#x27;李四&#x27;,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.describe() // &quot;姓名：张三&quot;</span><br><span class="line">B.describe() // &quot;姓名：李四&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。</p><p>只要函数被赋给另一个变量，this的指向就会变。</p><h5 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h5><p>this的使用可以分成以下几个场合。<br>（1）全局环境<br>在全局环境使用this，它指的就是顶层对象window。<br>（2）构造函数<br>构造函数中的this，指的是实例对象。<br>（3）对象的方法<br>当A对象的方法被赋予B对象，该方法中的this就从指向A对象变成了指向B对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。<br>（4）Node<br>在Node中，this的指向又分成两种情况。全局环境中，this指向全局对象global；模块环境中，this指向module.exports。</p><h5 id="函数执行方式this的指向"><a href="#函数执行方式this的指向" class="headerlink" title="函数执行方式this的指向"></a>函数执行方式this的指向</h5><p>最基本的有三种</p><p>1.普通的函数调用，this 谁调用就指谁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test () &#123;</span><br><span class="line">      console.log(111);</span><br><span class="line">      console.log(this);</span><br><span class="line">       &#125;</span><br><span class="line"> test();</span><br></pre></td></tr></table></figure><p>this也是window, 表示默认是使用window调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.test();</span><br></pre></td></tr></table></figure><p>2.作为对象的方法调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var stu = &#123;</span><br><span class="line">  name : &quot;张三&quot;,</span><br><span class="line"> age : 23,</span><br><span class="line"> play : function() &#123;</span><br><span class="line"> console.log(&quot;打篮球&quot;);</span><br><span class="line"> console.log(this)</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> stu.play();</span><br></pre></td></tr></table></figure><p>在分析的时候, 不用去管函数或者方法是怎样声明的, 只需要看函数调用,<br>谁调用这个这个方法或者函数, 那么this就指向谁<br>a.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test = stu.play;</span><br><span class="line">test();</span><br><span class="line">window.test();</span><br><span class="line">this指向的结果为：window</span><br><span class="line"></span><br><span class="line">test =  function() &#123;</span><br><span class="line">        console.log(&quot;打篮球&quot;);</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>b.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu.play = test;</span><br><span class="line">stu.play();</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">&#123;name:&quot;张三&quot;,age:23,play:f&#125;//this指向stu这个对象</span><br></pre></td></tr></table></figure><p>3.作为构造函数配合new关键字使用<br>this指向new关键字创建的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.age = age;</span><br><span class="line">      console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">  new Person(&quot;zhangsan&quot;,23);</span><br></pre></td></tr></table></figure><p>注意：<br>左值 : 就是指能够写在赋值运算符左边的值 比如变量<br>右值 : 就是指能够写在赋值运算符右边的值<br>this不能作为左值，会报错<br>上述三种函数执行的方式 缺点: 就是不能改变this指向</p><h5 id="改变this指向的方法"><a href="#改变this指向的方法" class="headerlink" title="改变this指向的方法"></a>改变this指向的方法</h5><p>call<br>apply<br>bind<br>函数的上下文调用模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;</span><br><span class="line">name:&quot;张三&quot;,</span><br><span class="line">age:23</span><br><span class="line">&#125;</span><br><span class="line">  function sum(n1, n2) &#123;</span><br><span class="line">      console.log(n1 + n2);</span><br><span class="line">      console.log(this); // 我不让this指向window, 要让this指向obj</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h6 id="call"><a href="#call" class="headerlink" title="call ()"></a>call ()</h6><p>语法结构 : 函数名.call(this的新指向, 参数1, 参数2, …)</p><p>call ()<br>语法结构 : 函数名.call(this的新指向, 参数1, 参数2, …)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum.call(obj,14, 3)</span><br><span class="line"> //结果为：17，&#123;name:&quot;张三&quot;,age:23&#125;</span><br></pre></td></tr></table></figure><h6 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h6><p>语法结构 : 函数.apply(this的新指向, 参数数组或者伪数组)<br>注意 : apply方法只有两个参数</p><p>apply()<br>语法结构 : 函数.apply(this的新指向, 参数数组或者伪数组)<br>注意 : apply方法只有两个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum.apply(obj,[16, 8])</span><br><span class="line"> //结果为：24，&#123;name:&quot;张三&quot;,age:23&#125;</span><br></pre></td></tr></table></figure><h6 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h6><p>语法结构 : 函数名.bind(this的新指向, 参数1, 参数2, …)<br>特点 :<br>1.不会指向这个要修改this指向的函数的函数, 而是返回已经修改了this指向的函数<br>2.bind不传参, 那么就在调用修改了this指向后的函数时传参, 但是如果两个都传了, 那么接受bind的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fun = sum.bind(obj);</span><br><span class="line">fun(15,8)</span><br><span class="line">//结果为：23，&#123;name:&quot;张三&quot;,age:23&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fun = sum.bind(obj,10,11);</span><br><span class="line">fun(15,8)</span><br><span class="line"> //结果为：21，&#123;name:&quot;张三&quot;,age:23&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fun = sum.bind(obj,10,11);</span><br><span class="line">  fun(15,8)</span><br><span class="line">   //结果为：21，&#123;name:&quot;张三&quot;,age:23&#125;</span><br></pre></td></tr></table></figure><h4 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h4><h5 id="1-for…in"><a href="#1-for…in" class="headerlink" title="1.for…in"></a>1.for…in</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;</span><br><span class="line">id:1,</span><br><span class="line">name:&quot;张三&quot;,</span><br><span class="line">age:18</span><br><span class="line">&#125;</span><br><span class="line">for(var key in obj)&#123;</span><br><span class="line">console.log(key+&quot;----&quot;+obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id----1</span><br><span class="line">name----张三</span><br><span class="line">age----18</span><br></pre></td></tr></table></figure><h5 id="2-Object-keys、Object-values"><a href="#2-Object-keys、Object-values" class="headerlink" title="2.Object.keys、Object.values"></a>2.Object.keys、Object.values</h5><p>(1)Object.keys(对象名)<br>(2)Object.values(对象名)<br>参数：要返回其遍历自身属性的对象<br>返回值：一个表示给定对象的所有可遍历属性的字符串数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;</span><br><span class="line">id:1,</span><br><span class="line">name:&quot;张三&quot;,</span><br><span class="line">age:18</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.key(obj));</span><br><span class="line">console.log(Object.values(obj));</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.obj对象的key组成的数组</span><br><span class="line">[‘id’,‘name’,‘age’]</span><br><span class="line">2.obj对象的value组成的数组</span><br><span class="line">[‘1’,‘张三’,‘18’]</span><br></pre></td></tr></table></figure><h5 id="3-Object-getOwnPropertyNames"><a href="#3-Object-getOwnPropertyNames" class="headerlink" title="3.Object.getOwnPropertyNames"></a>3.Object.getOwnPropertyNames</h5><p>使用Object.getOwnPropertyNames(对象名)<br>返回一个数组，包含对象自身的所有属性（包含不可遍历属性）<br>遍历可以获取key和value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;</span><br><span class="line">id:1,</span><br><span class="line">name:&quot;张三&quot;,</span><br><span class="line">age:18</span><br><span class="line">&#125;</span><br><span class="line">Object.getOwnPropertyNames(obj).forEach(function(key)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(key+&quot;---&quot;+obj[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​</p><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id—1</span><br><span class="line">name—‘张三’</span><br><span class="line">age—18</span><br></pre></td></tr></table></figure><h4 id="JS基本包装类型"><a href="#JS基本包装类型" class="headerlink" title="JS基本包装类型"></a>JS基本包装类型</h4><p>JS基本包装类型<br>将基本数据类型包装成对象，并赋予他一些方法，JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换成对象</p><p>1.String()<br>可以将基本数据类型字符串转换成String对象<br>2.Number()<br>可以将基本数据类型的数字转换为Number对象<br>3.Boolean()<br>可以将基本数据类型的布尔值转换为Boolean对象</p><p>方法和属性只能添加给对象，不能添加给基本数据类型，当对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后调用对象的属性和方法，调用完后再将其转换为基本数据类型</p><pre><code>    var num=123;    num=newNumber(123);    var numStr=num.toString();</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在开发过程中, 一段代码在多个地方执行, 而且不连续执行的时候可以使用函数</p><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>1.函数声明 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line">函数体 : 代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数声明的特点 : 只是将一段代码保存在变量里面, 但是不会执行</p><p>2.函数调用 </p><p>调用语法 : <code>函数名();</code><br>特点 : 执行保存在函数体里面的代码<br>buySmoking();</p><h5 id="函数的好处"><a href="#函数的好处" class="headerlink" title="**函数的好处 **"></a>**函数的好处 **</h5><p>(1) 解决代码冗余的问题, 便于维护<br>(2) 使用方便</p><h5 id="和循环的区别"><a href="#和循环的区别" class="headerlink" title="**和循环的区别 **"></a>**和循环的区别 **</h5><p>(1) 作用不一样<br>循环 : 只能在同一个地方,重复执行同一段代码<br>函数 : 可以在多个地方, 重复执行同一段代码<br>(2) 本质不一样<br>循环 : 只是一种语法, 代表代码重复执行<br>函数 : 是一种数据类型, 里面存储的是一段代码</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>1.函数的参数 : 让调用者可以传递数据给函数<br>函数参数是在函数内部声明的一个变量 声明的时候, 并没有赋值 我们把它叫做形参(形式参数)</p><p>参数声明语法 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> function 函数名(形参) &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数的赋值 : 是发生在调用阶段 我们传递的数据叫做实参(实际参数)<br>参数赋值语法 : 函数名(实参);</p><p>2.函数的形参可以是多个 多个形参之间使用逗号隔开 如果调用的时候不传参数(实参), 参数就是undefined, 如果只传一个 那么就是只给第一个</p><p>3.在调用的时候, 实参的个数可以不和形参相等, 实参的赋值是按照形参的顺序进行赋值</p><p>4.函数的每一次调用都是独立的</p><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>break 跳出循环 （终止循环）<br>return 终止函数的执行， 并将指定的值返回给调用者<br>作用和break在循环中类似, 对于return以后的函数体代码都不会执行</p><p>函数的返回值<br>返回值就是return 终止函数体执行之后, 返回给调用者的数据</p><ol><li>如果没有return 或者return后面没有接值, 那么函数的返回值是undefined</li><li>如果return后面接了值, 那么就返回该值</li><li>return 只能用在函数体中, 用在其他语句中, 会出现报错</li></ol><p>参数 :<br>传参数 : 调用者<br>接参数 : 函数接</p><p>返回值 可以声明一个变量来接收 </p><p><code>var 变量名 = 函数名(参数);</code></p><p>无参数 无返回值 用得少 因为无参数无返回值 就是单纯执行一段代码<br>有参数无返回值 用得少 只是在函数内部做一些运算, 输出数据<br>无参数有返回值 用得少<br>有参数有返回值 用的最多 根据外部传入的数据进行计算, 将运算结果返回给调用者</p><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>变量作用域就是变量可以起作用范围</p><p>变量作用域的分类 :<br>(1) 全局作用域 全局变量 : 就是可以在全局作用域范围内起作用<br>(2) 局部作用域(函数作用域) : 有函数划分出来的作用域<br>局部作用域里面声明的变量 叫做局部变量<br>函数可以分割作用域 就是局部作用域<br>特殊点 : 所有没有使用var定义的变量都是全局变量<br>(3) 块级作用域 块级作用域通过let和const关键字来实现</p><h5 id="let"><a href="#let" class="headerlink" title="let"></a>let</h5><p>作用和var一样 都是用来声明变量的<br>a. 在同一作用域内 不能重复声明<br>b. let声明的变量不能在声明前使用<br>c. 变量的暂时性死区 : 在有一个作用域内 从作用域顶端到变量定义之前<br>d. let只在块级作用域里面起作用 块级 : 指的是代码块 { }</p><p>块级<br>指的是一对大括号包起来的部分, 函数 if for 这些结构里面声明的变量都只能在对应的大括号里面起作用</p><h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><p>用来声明常量的, 在同一作用域内, 不能重新声明, 也不能重新赋值</p><p>最外层函数和在最外层函数外面定义的变量都拥有全局作用域<br>所有未定义直接赋值的变量都拥有全局作用域<br>所有window对象的属性拥有全局作用域<br>window.name window.location</p><h5 id="变量的提升"><a href="#变量的提升" class="headerlink" title="变量的提升"></a>变量的提升</h5><p>程序在执行时, 变量的声明提升到所在作用域的最顶端, 赋值留在原地, 按照顺序结构执行</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>作用域链是怎么来的 ?<br>我们默认js代码都处于全局作用域中, 当我们声明一个函数之后, 这个函数就分割出了一个局部作用域, 然后我在这个函数的函数体里面再声明一个函数, 又会开辟出新的局部作用域, 以此类推, 就形成了一个嵌套多层的作用域链</p><p>作用域链的访问规则 :<br>就近原则 先从本级作用域查找, 找不到依次往上找, 找到顶级作用域还没有, 就会报错</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归函数就是在函数体内调用本函数；</p><p>递归函数的使用要注意函数终止条件避免死循环；</p><h5 id="递归实现形式"><a href="#递归实现形式" class="headerlink" title="递归实现形式"></a>递归实现形式</h5><p>1.声明一个具名函数，通过函数名调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f(a)&#123;</span><br><span class="line">    if(a&lt;=1)&#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return a*f(a-1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p>但是这样使用会因为 函数名 f 的变化而报错，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = null</span><br><span class="line">f ()  // Uncaught TypeError: f is not a function</span><br></pre></td></tr></table></figure><p>2.使用arguments.callee代替函数名</p><p>在严格模式下不支持使用arguments.callee</p><p>3.使用函数表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var fun = (function f(a)&#123;</span><br><span class="line">    if(a&lt;=1)&#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return a*f(a-1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 或：</span><br><span class="line"></span><br><span class="line">var f = function (a)&#123;</span><br><span class="line">    if(a&lt;=1)&#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return a*f(a-1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fun = f;</span><br></pre></td></tr></table></figure><h5 id="递归返回值"><a href="#递归返回值" class="headerlink" title="递归返回值"></a>递归返回值</h5><p>1.递归函数相当于一种循环调用，需要避免死循环，给定一个条件停止调用</p><p>2.递归函数的返回值要返回整个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 返回公约数的数组集合</span><br><span class="line">let fun = (function f(a,n = 1,b=[])&#123;</span><br><span class="line">  if(a%n === 0) &#123;</span><br><span class="line">     b.push(n)            </span><br><span class="line">    &#125;</span><br><span class="line">   n ++;</span><br><span class="line">   if(n&gt;a)&#123;</span><br><span class="line">   return b</span><br><span class="line"> &#125;</span><br><span class="line"> return f(a,n,b) // *** 要返回整个函数，不能只是return b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>调用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun(4)</span><br><span class="line">[1, 2, 4]</span><br></pre></td></tr></table></figure><p>在 *** 处要返回整个函数，</p><p>这是因为当执行条件 n&gt;a 不成立时是没有返回值的，例如，第一次执行时 n&#x3D;1，a&#x3D;4，1&gt;4 为false因而没有返回值，接着之后的值也都没有返回</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 可以参考这种形式，有return fun</span><br><span class="line">fun ()&#123;</span><br><span class="line">return fun()&#123;</span><br><span class="line"> return fun()&#123;</span><br><span class="line">   return 4</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以参考这种形式，没有return fun</span><br><span class="line">fun ()&#123;</span><br><span class="line">fun()&#123;</span><br><span class="line"> fun()&#123;</span><br><span class="line">   return 4</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><h5 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h5><p>在函数内部是可以读取到全局变量的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var n1 = 12;</span><br><span class="line">  function f1 () &#123;</span><br><span class="line">      alert(n1);</span><br><span class="line"> &#125;</span><br><span class="line">  f1(); // 12</span><br></pre></td></tr></table></figure><h5 id="2-在函数外部访问不到函数内部声明的局部变量"><a href="#2-在函数外部访问不到函数内部声明的局部变量" class="headerlink" title="2.在函数外部访问不到函数内部声明的局部变量"></a>2.在函数外部访问不到函数内部声明的局部变量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f2() &#123;</span><br><span class="line">        var n2 = 12;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(n2);</span><br></pre></td></tr></table></figure><h5 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h5><p>这里的f4 就是闭包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  function f3 () &#123;</span><br><span class="line">        var n3 = 12;</span><br><span class="line"></span><br><span class="line">   function f4() &#123;</span><br><span class="line">        alert(n3);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return f4;</span><br><span class="line"></span><br><span class="line">   // f4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var res = f3();</span><br><span class="line">console.log(res);</span><br><span class="line">res();</span><br></pre></td></tr></table></figure><h5 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h5><p>就是在函数内部声明一个函数, 这个函数可以访问函数内部声明的局部变量 那么这个函数就叫做闭包<br>理解 : 之后函数内部的子函数才可以访问函数内部声明的局部变量<br>全局变量：可以反复使用，随处可用（容易造成全局污染）<br>全局变量的生命周期：从变量声明开始到程序运行结束<br>局部变量：不可以重复使用，只在函数中使用<br>局部变量的生命周期 : 从变量声明开始到声明这个局部变量的函数执行完回收</p><pre><code> function f1() &#123;         var ranNum = Math.floor(Math.random() * 100);        function f2() &#123;            console.log(ranNum);        &#125;         return f2;     &#125;    var fun = f1();   fun();   fun();f1()();f1()();function fun() &#123;    var num = 13;&#125;console.log(num);</code></pre><h5 id="闭包的优点"><a href="#闭包的优点" class="headerlink" title="闭包的优点"></a>闭包的优点</h5><p>可以使用重复变量有保护变量不被污染的一种机制。<br>需求 : 在函数外部访问函数内部的局部变量, 怎么访问?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1.用外层函数包裹受保护的变量和操作变量的内层函数</span><br><span class="line">function outer()&#123;</span><br><span class="line">var i=1 </span><br><span class="line">//活动对象，函数作用域</span><br><span class="line">//2.外层函数将内层函数返回</span><br><span class="line">return function getNum()&#123;</span><br><span class="line">console.log(i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//3.使用者调用外层函数，获得内层函数的对象</span><br><span class="line">var getNum=outer();</span><br><span class="line">getNum();//1</span><br><span class="line">getNum();//2</span><br><span class="line">getNum();//3</span><br><span class="line">getNum();//4</span><br></pre></td></tr></table></figure><h5 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h5><p>1.提升局部变量的生命周期<br>全局变量的生命周期：从变量声明开始到程序运行结束<br>局部变量的生命周期 : 从变量声明开始到声明这个局部变量的函数执行完回收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">var num=12;</span><br><span class="line">function f2()&#123;</span><br><span class="line">console.log(num);</span><br><span class="line">&#125;</span><br><span class="line">return f2;</span><br><span class="line">&#125;</span><br><span class="line">var res=f1();</span><br><span class="line">res();</span><br></pre></td></tr></table></figure><h4 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h4><p>1，它是一个函数。<br>2，它用来创建对象。<br>3，它像工厂一样，生产出来的函数都是拥有同样的属性<br>工厂函数可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function students(name,age,grade)&#123;</span><br><span class="line">//1.创建一个对象</span><br><span class="line">var stu=&#123; &#125;；</span><br><span class="line">//2.给对象里面的属性赋值</span><br><span class="line">stu.name=name;</span><br><span class="line">stu.age=age;</span><br><span class="line">stu.grade=grade;</span><br><span class="line">//3.返回创建好的对象</span><br><span class="line">return stu；</span><br><span class="line">&#125;</span><br><span class="line">var banzhang=students(&quot;张三&quot;,15,&quot;三年级&quot;);</span><br><span class="line">console.log(banzhang);</span><br></pre></td></tr></table></figure><h4 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建对象：</span><br><span class="line">function students(name,age)&#123;</span><br><span class="line">//完成对象的赋值</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">var s1=new students(&quot;张三&quot;,16);</span><br><span class="line">console.log(s1);</span><br></pre></td></tr></table></figure><p>本质也是一个函数（系统自带的函数）用new关键字来调用函数</p><h5 id="new关键字的作用"><a href="#new关键字的作用" class="headerlink" title="new关键字的作用"></a>new关键字的作用</h5><p>1.自动创建一个空对象<br>2.将this指向创建的这个对象<br>3.完成对象的赋值（执行构造函数代码）<br>4.返回创建的对象</p><p>本质也是一个函数（系统自带的函数）用new关键字来调用函数<br>new关键字的作用：<br>1.自动创建一个空对象<br>2.将this指向创建的这个对象<br>3.完成对象的赋值（执行构造函数代码）<br>4.返回创建的对象</p><h4 id="工厂函数与自定义构造函数的区别"><a href="#工厂函数与自定义构造函数的区别" class="headerlink" title="工厂函数与自定义构造函数的区别"></a>工厂函数与自定义构造函数的区别</h4><h5 id="工厂函数-1"><a href="#工厂函数-1" class="headerlink" title="工厂函数"></a>工厂函数</h5><p>本质就是一个函数，将创建对象的代码进行封装成函数<br>特点：创建出来的类型都是Object类型<br>注意点：1.返回值—调用时通过传过来的实参对对象进行具体的赋值</p><h5 id="自定义构造函数-1"><a href="#自定义构造函数-1" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h5><p>特征:需要结合new使用，创建出来的对象有自己的类型<br>构造函数的特点：<br>构造函数，就是一个函数<br>首字母大写<br>Js中内置了一些Array Object<br>可以自定义</p><h5 id="两种函数声明方式"><a href="#两种函数声明方式" class="headerlink" title="两种函数声明方式"></a>两种函数声明方式</h5><p>函数声明方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line"> 函数体</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>函数表达式声明方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> var 函数名 = function() &#123;</span><br><span class="line"> 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种声明方式的<strong>区别</strong> :<br>1.函数声明方法 : 由于函数声明的提升, 可以再任意位置调用,<br>2.函数表达式式声明 只能在函数声明之后去调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sum(n1, n2) &#123;</span><br><span class="line">console.log(n1 + n2); </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   sum(2, 3);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var sum = function(n1, n2) &#123;</span><br><span class="line">     console.log(n1 + n2); </span><br><span class="line"> &#125;</span><br><span class="line"> sum(2, 3);</span><br></pre></td></tr></table></figure><h4 id="函数的工作原理"><a href="#函数的工作原理" class="headerlink" title="函数的工作原理"></a>函数的工作原理</h4><p>作用：可以让代码复用，实现一个独立的小功能<br>JS的预解析(预编译)机制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> console.log(a);</span><br><span class="line"> var a=12;</span><br><span class="line">//就相当于</span><br><span class="line">var a;</span><br><span class="line">console.log(a);</span><br><span class="line">a=12;</span><br></pre></td></tr></table></figure><h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><h5 id="预编译的好处"><a href="#预编译的好处" class="headerlink" title="预编译的好处"></a>预编译的好处</h5><p>可以让函数在任意位置调用。</p><h5 id="什么是预编译机制"><a href="#什么是预编译机制" class="headerlink" title="什么是预编译机制"></a>什么是预编译机制</h5><p>就是JS代码执行前，会把函数或者变量声明提升到所在作用域的最顶端<br>注意点：<br>只是声明提前（变量声明和函数声明）变量的赋值和函数的调用留在原地，依次执行。</p><p>预编译的好处:<br>可以让函数在任意位置调用。<br>什么是预编译机制<br>就是JS代码执行前，会把函数或者变量声明提升到所在作用域的最顶端<br>注意点：<br>只是声明提前（变量声明和函数声明）变量的赋值和函数的调用留在原地，依次执行。</p><h5 id="GO与AO"><a href="#GO与AO" class="headerlink" title="GO与AO"></a>GO与AO</h5><p>代码的执行过程<br>1.语法检测：函数执行前，先扫描一遍，看看有没有语法错误，有就报错，没有就进行预编译<br>2.预编译：GO对象（Global Object）全局对象</p><p>a. 生成一个GO对象，封装的就是作用域<br>GO&#x3D;{}</p><p>b. 分析变量声明（var），就是声明的变量名作为GO对象的属性名，值为undefined<br>c.分析函数声明，函数名作为GO对象的属性名，属性值为函数体，如果遇到同名函数，直接覆盖<br>当遇到有变量和函数名同名的时候，变量提升的优先级大于函数提升的优先级（先进行变量提升，再进行函数提升）。<br>d.到走到某一行的时候，当变量产生一次赋值，那么GO对象就发生变化。</p><p>3.运行执行（对照着GO对象里面执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">function fun()&#123;&#125;;</span><br><span class="line">function abc()&#123;&#125;;</span><br><span class="line">function a()&#123;&#125;;</span><br><span class="line">console.log(a);</span><br><span class="line">var a=12;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">//1.声明一个GO对象：</span><br><span class="line">GO=&#123;&#125;;</span><br><span class="line">//2.分析变量声明:（var）</span><br><span class="line">GO=&#123;</span><br><span class="line">a:undefined,</span><br><span class="line">&#125;</span><br><span class="line">//3.分析函数声明（function）：</span><br><span class="line">GO=&#123;</span><br><span class="line">a:undefined,</span><br><span class="line">fun:function fun()&#123;&#125;,</span><br><span class="line">abc:function abc()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//4.走到某一步，产生赋值之后，GO对象发生变化</span><br><span class="line">GO=&#123;</span><br><span class="line">a:12,</span><br><span class="line">fun:function fun()&#123;&#125;,</span><br><span class="line">abc:function abc()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数被调用执行前的一个瞬间，会生成一个AO（Active Object）对象，每一次调用函数都会生成一个<br>AO对象，多次调用产生的AO对象之间没有任何关系<br>1.在函数执行前的瞬间，产生一个AO对象<br>AO&#x3D;{ }<br>2.分析参数，形参作为AO对象的属性名，实参作为属性值<br>3.分析变量声明，变量名作为属性名，值为undefined,如果遇到同名的，不发生任何改变<br>4.分析函数声明，函数名作为属性名，函数体为属性值。如果遇到同名的，直接覆盖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var a=100;</span><br><span class="line">function fun (a)&#123;</span><br><span class="line">console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">fun(5);</span><br><span class="line"></span><br><span class="line">//1.函数运行瞬间，生成一个AO对象</span><br><span class="line">AO=&#123;&#125;</span><br><span class="line">//2.分析参数，形参作为属性名，实参作为属性值</span><br><span class="line">AO=&#123;</span><br><span class="line">a:5</span><br><span class="line">&#125;</span><br><span class="line">//3.分析变量声明（var），没有就略过</span><br><span class="line">//4.分析函数声明（function）没有就略过</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回调函数<br>在本函数执行完毕后, 根据不同的情况, 可能需要调用不同的函数,<br>那么我们可以把这个函数当参数传进来, 然后再调用,<br>回调函数本质是一个参数<br>回调函数可以传三个参数<br>function(value(元素), index(索引), array(数组));</p><pre><code>function arrSum(num) &#123;               console.log(num());    &#125;function num1() &#123;        return 30;    &#125;arrSum(num1);</code></pre><h5 id="sort-函数中的比较器"><a href="#sort-函数中的比较器" class="headerlink" title="sort 函数中的比较器"></a>sort 函数中的比较器</h5><p>实现方法：</p><pre><code>var arr = [2 , 3, -1, -107, -14, 1];        console.log(arr.sort(function(a,b)&#123;                if(a&lt;b)&#123;                    return -1;                &#125;                if(a&gt;b)&#123;                    return 1;                &#125;                return 0;            &#125;))</code></pre><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h6><p>forEach是ECMA5中Array新方法中最基本的一个，就是遍历，循环。</p><pre><code>var array = [1, 2, 3, 4];     array.forEach(alert);//弹出数组每一个数</code></pre><h4 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h4><p>自己调用自己<br>自调用函数 语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123; </span><br><span class="line">函数体</span><br><span class="line">&#125;)()  </span><br></pre></td></tr></table></figure><p>一般来说 都是匿名函数的自调用<br>自调用函数(自执行函数)的作用 : 主要是用来分隔作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var num = 111;</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">    var num = 111;</span><br><span class="line">    console.log(11);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">function sum(n1, n2) &#123;</span><br><span class="line">    console.log(n1 + n2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(2,3);</span><br></pre></td></tr></table></figure><h4 id="具名函数"><a href="#具名函数" class="headerlink" title="具名函数"></a>具名函数</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名()&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fun(n1,n2)&#123;</span><br><span class="line">console.log(n1+n2);</span><br><span class="line">&#125;</span><br><span class="line">fun(2.3)</span><br></pre></td></tr></table></figure><p>具名函数可以自调用，但不会那么去用</p><h5 id="具名函数的四种调用方式"><a href="#具名函数的四种调用方式" class="headerlink" title="具名函数的四种调用方式"></a>具名函数的四种调用方式</h5><p>1.():最常用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//无参函数fun1  </span><br><span class="line">function fun1() &#123;  </span><br><span class="line">    alert(&#x27;我被调用了&#x27;);  </span><br><span class="line">&#125;  </span><br><span class="line">fun1()  </span><br><span class="line"></span><br><span class="line">//有参函数fun2  </span><br><span class="line">function fun2(param) &#123;  </span><br><span class="line">    alert(param);  </span><br><span class="line">&#125;  </span><br><span class="line">fun2(&#x27;我被调用了&#x27;)  </span><br></pre></td></tr></table></figure><p>2.call</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//无参函数fun1  </span><br><span class="line">function fun1() &#123;  </span><br><span class="line">    alert(&#x27;我被调用了&#x27;);  </span><br><span class="line">&#125;  </span><br><span class="line">fun1.call(null);  </span><br><span class="line"></span><br><span class="line">//有参函数fun2  </span><br><span class="line">function fun2(param) &#123;  </span><br><span class="line">    alert(param);  </span><br><span class="line">&#125;  </span><br><span class="line">fun2.call(null,&#x27;我被调用了&#x27;)  </span><br></pre></td></tr></table></figure><p>3.apply</p><p>3.apply</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//无参函数fun1  </span><br><span class="line">function fun1() &#123;  </span><br><span class="line">    alert(&#x27;我被调用了&#x27;);  </span><br><span class="line">&#125;  </span><br><span class="line">fun1.apply(null);  </span><br><span class="line"></span><br><span class="line">//有参函数fun2  </span><br><span class="line">function fun2(param) &#123;  </span><br><span class="line">    alert(param);  </span><br><span class="line">&#125;  </span><br><span class="line">fun2.apply(null,[&#x27;我被调用了&#x27;])  </span><br></pre></td></tr></table></figure><p>4.new（不推荐使用这种方法）<br>当返回值是对象类型（对象，数组，函数）时，<br>new不会用this去构造对象，而直接返回组装的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//无参函数fun1  </span><br><span class="line">function fun1() &#123;  </span><br><span class="line">    alert(&#x27;我被调用了&#x27;);  </span><br><span class="line">&#125;  </span><br><span class="line">new fun1();  </span><br><span class="line"></span><br><span class="line">//有参函数fun2  </span><br><span class="line">function fun2(param) &#123;  </span><br><span class="line">    alert(param);  </span><br><span class="line">&#125;  </span><br><span class="line">new fun2(&#x27;我被调用了&#x27;)</span><br></pre></td></tr></table></figure><h4 id="valueof-方法"><a href="#valueof-方法" class="headerlink" title="valueof()方法"></a>valueof()方法</h4><p>复杂数据类型和简单数据类型进行运算, 先调用复杂数据类型的valueof方法,<br>如果调用了valueof方法还无法进行运算, 那么就调用复杂数据类型的toString方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//判断[] == ![]</span><br><span class="line">console.log([] == ![]); // true</span><br></pre></td></tr></table></figure><pre><code>    //![]  ===  false    // []  == false    // console.log([].valueOf());    // console.log([].toString());    // console.log(typeof [].toString());    // &quot;&quot; == false</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//判断&#123;&#125; == !&#123;&#125;</span><br><span class="line">       console.log(&#123;&#125; == !&#123;&#125;); // false</span><br></pre></td></tr></table></figure><p>​        </p><p>​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#125; == false</span><br><span class="line">    // console.log(&#123;&#125;.valueOf());</span><br><span class="line">    // console.log(&#123;&#125;.toString());</span><br><span class="line">    // console.log(typeof &#123;&#125;.toString());</span><br><span class="line">    // &quot;[object Object]&quot; == false</span><br></pre></td></tr></table></figure><h4 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h4><p>具有length属性；长度不可变是自定义的一个属性<br>按索引方式存储数据；<br>不具有数组的push()、pop()等方法（不能使用数组中的方法）；</p><h5 id="arguments关键字"><a href="#arguments关键字" class="headerlink" title="arguments关键字"></a>arguments关键字</h5><p>arguments 只能在函数里面使用, 在函数外使用 就会报错<br>arguments的作用 : 获取函数的所有实参<br>arguments是一个伪数组。<br>修改了形参, arguments也会随之改变<br>修改了arguments的值, 形参也会发生改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function sum(n1, n2) &#123;</span><br><span class="line"></span><br><span class="line">// 修改了形参, arguments也会随之改变</span><br><span class="line"> n1 = 100;</span><br><span class="line">console.log(arguments);</span><br><span class="line">arguments[0] = 300;</span><br><span class="line"></span><br><span class="line">// 修改了arguments的值,  形参也会发生改变</span><br><span class="line">console.log(n1, n2);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">sum(2, 3);</span><br><span class="line"></span><br><span class="line">sum(22);</span><br><span class="line"></span><br><span class="line">sum(22, 33, 44)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 根据传入的参数不同  函数做不同的运算</span><br><span class="line">// 传一个参数  求这个参数的平方</span><br><span class="line">// 传两个参数  就求积</span><br><span class="line">// 传三个参数  就求和</span><br><span class="line">function sum(n1, n2) &#123;</span><br><span class="line">if(arguments.length==1)&#123;</span><br><span class="line">document.write(n1*n1+&quot;&lt;br&gt;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if(arguments.length==2)&#123;</span><br><span class="line">document.write(n1+n2+&quot;&lt;br&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if(arguments.length==3)&#123;</span><br><span class="line">document.write(n1+n2+arguments[arguments.length-1]+&quot;&lt;br&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">sum(2, 3);</span><br><span class="line"></span><br><span class="line">sum(22);</span><br><span class="line"></span><br><span class="line">sum(22, 33, 44)</span><br></pre></td></tr></table></figure><h2 id="数据运算符"><a href="#数据运算符" class="headerlink" title="数据运算符"></a>数据运算符</h2><p>1.字符串连接符 如果 + 两边有一边是字符串, 那么他就是字符串连接符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 + 1 + &quot;a&quot; + 1 + 1);        </span><br><span class="line">console.log(1 + 1 + &quot;a&quot; + (1 + 1));</span><br></pre></td></tr></table></figure><p>2.赋值运算符 &#x3D; 把运算符右边的值, 赋值给左边的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var num1 = 23;       </span><br><span class="line">num1 = num2;        </span><br><span class="line">console.log(num1);</span><br></pre></td></tr></table></figure><p>3.算术运算符 + - * &#x2F; %</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 + 1);        </span><br><span class="line">console.log(2 - 1);        </span><br><span class="line">console.log(1 * 2);</span><br></pre></td></tr></table></figure><p>​注意点 :</p><p>（1）数学里面除数不能为零 js里面也一样 如果0做了除数, 那么得到的结果是Infinity<br>（2） 除法会得到无理数或者无限循环小数 不影响开发<br>（3）尽量不要使用小数去运算 会失去精确度<br>（4）% 求模 取余 求除法的余数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(10 % 3);</span><br></pre></td></tr></table></figure><p>4.关系运算符 <code>&lt; , &gt; , &lt;= , &gt;= , != , == , !== , ===</code></p><p>表达式 : 有运算符和操作数组成的式子 关系表达式的结果只有两种结果 布尔类型的 true false</p><p><code>==</code> 是比较两个数据的值是否相等 不比较数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> == <span class="string">&quot;3&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>===</code> 比较两个数据的数值和数据类型是否全等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(null === undefined);    console.log(3 === 3);    </span><br><span class="line">console.log(3 === &quot;3&quot;);</span><br></pre></td></tr></table></figure><p>5.逻辑运算符 &amp;&amp; || ! 逻辑运算符是比较多个关系表达式之间的关系 逻辑运算符的结果不只是布尔类型的值</p><p>（1）逻辑与 &amp;&amp; 一假则假</p><p>（2）逻辑或 || 一真则真</p><p>（3） 逻辑非 ! true变false false变true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(!true);   // false           </span><br><span class="line">console.log(!false);  // true</span><br></pre></td></tr></table></figure><p>6.复合运算符：<br>（1）+&#x3D;：在自身基础上加多少<br>（2）-&#x3D;：在自身基础上减多少<br>（3）*&#x3D;：在自身基础上乘多少<br>（4）&#x2F;&#x3D;：在自身基础上除多少<br>（5）%&#x3D;：在自身基础上模于多少<br>（6）++：在自身基础上加1，分为前自增和后自增<br>前自增：先自身加1，再运算 <code>var num=++num</code><br>后自增：先运算，再自身加1 <code>var num=num++</code><br>（7）- -：在自身基础上减1，分为前自减和后自减（原理和++一样）</p><p>7.运算符的优先级：（从高到低）</p><p>（1）（）可以用来提升优先级<br>（2）自增自减<br>（3）算术运算符<br>（4）关系运算符<br>（5）逻辑运算符<br>（6）赋值运算符</p><h2 id="短路运算"><a href="#短路运算" class="headerlink" title="短路运算"></a>短路运算</h2><p>在逻辑表达式中，如果第一个式子就可以决定整个逻辑表达式的结果，那么第二个式子就不用计算了<br>1.逻辑与的短路运算：找假<br>在逻辑与表达式中，如果第一个式子的结果为false，那么该逻辑表达式的结果就是第一个式子的值，否则就是第二个式子的值</p><p>2.逻辑或的短路运算：找真<br>在逻辑或表达式中，如果第一个式子的结果为true，那么该逻辑表达式的结果就是第一个式子的值，否则就是第二个式子的值</p><p>3.逻辑非没有短路运算</p><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>语法结构 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (表达式) &#123;</span><br><span class="line">条件成立时执行的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式可以是哪些 :</p><p>关系表达式<br>布尔类型的值<br>其他类型的值<br>if结构里面的{} 在条件成立时需要执行的代码只有一行时可以省略, 但是一般不要省略</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><p>(用的最多)<br>语法结构 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(表达式) &#123;</span><br><span class="line">条件成立时执行的代码(代码1)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">条件不成立时执行的代码(代码2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if () &#123;</span><br><span class="line"></span><br><span class="line">&#125; else&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法解析 :</p><p>当表达式成立时, 执行代码1, 否则执行代码2<br>if-else 是表示两个互斥的结构, 只满足其中一个 , 两个大括号的里面的代码不可能同时执行<br>else 后面绝对不能接()</p><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h3><p>语法结构 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if(条件1) &#123;</span><br><span class="line">条件1成立时执行的代码</span><br><span class="line">&#125; else if (条件2) &#123;</span><br><span class="line">条件2成立时执行的代码</span><br><span class="line">&#125;</span><br><span class="line">…</span><br><span class="line">else &#123;</span><br><span class="line">以上条件都不满足的时候, 执行的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if()&#123;</span><br><span class="line"></span><br><span class="line">&#125;else if()&#123;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点 :</p><p>if-else if 是做多条件判断的<br>所有大括号里面的代码只会执行一个</p><h3 id="swicth-case"><a href="#swicth-case" class="headerlink" title="swicth case"></a>swicth case</h3><p>switch-case 主要用于固定值匹配<br>switch-case 匹配规则 : 匹配值必须是全等的<br>break的作用 : 是用来结束switch-case语句的 可以不写, 但是不写 会出现穿透现象（防止穿透）<br><strong>break</strong>只能用于switch语句和循环语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> switch ()&#123;</span><br><span class="line">case value:</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构 :"></a>循环结构 :</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>代码结构 :<br>while(条件 true&#x2F; false) {<br>循环体 : 重复执行的代码<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while ()&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>特点 : 先奏后斩<br>结构解析 :<br>判断条件是否成立, 如果成立, 执行循环体代码, 重复判断条件是否成立<br>如果不成立, 跳出循环, 执行大括号之后的代码</p><p>条件语句可以是哪些 :</p><p>1.关系表达式</p><p>2.布尔类型的值</p><p>3.其他类型的值 (都会转换成布尔类型)</p><h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><p>do-while 结构</p><p>do {<br>循环体 : 条件成立时重复执行的代码<br>} while (判断条件 true &#x2F; false);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line"></span><br><span class="line">&#125;while()</span><br></pre></td></tr></table></figure><p>结构解析 : 先无条件执行一遍循环体, 然后再判断, 如果条件成立, 就重复执行循环体代码<br>特点 : 先斩后奏</p><p>结构解析 : 先无条件执行一遍循环体, 然后再判断, 如果条件成立, 就重复执行循环体代码<br>特点 : 先斩后奏</p><h3 id="for循环结构"><a href="#for循环结构" class="headerlink" title="for循环结构"></a>for循环结构</h3><p>(最常用) :<br>for(语句1 ; 语句2 ; 语句3) {<br>循环体 : 条件成立时重复执行的代码<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;5;i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句1 : 声明一个变量, 来记录循环次数, 叫做循环变量<br>语句2 : 判断条件(通常是条件表达式), 他是用来控制循环的结束还是继续<br>语句3 : 通常都是循环变量的自增或者自减</p><p>语句1 : 声明一个变量, 来记录循环次数, 叫做循环变量<br>语句2 : 判断条件(通常是条件表达式), 他是用来控制循环的结束还是继续<br>语句3 : 通常都是循环变量的自增或者自减</p><p>结构解析 :</p><ol><li>执行语句1(声明循环变量)</li><li>执行语句2, 判断条件是否成立：<br>（1） 如果成立 执行循环体代码<br>（2） 循环变量自增, 重复执行步骤2<br>如果不成立, 就跳出循环, 执行大括号外面的代码</li></ol><h3 id="三种循环结构的适用场景"><a href="#三种循环结构的适用场景" class="headerlink" title="三种循环结构的适用场景"></a>三种循环结构的适用场景</h3><p><strong>while</strong> : 适用于循环次数不固定的场景<br><strong>do-while</strong> : 适用于循环次数不固定的场景, 但是循环体代码必须无条件执行一次<br><strong>for</strong> : 适用于循环次数固定的场景</p><p>三种循环的<strong>注意点</strong> :<br><strong>for</strong> :</p><p>小括号里面的语句都可以省略, 但是分号不能省略, 三个语句都省略了, 就变成死循环了<br>循环变量的定义可以提到循环外<br>循环变量自增可以写在循环体里面</p><p><strong>while</strong> :</p><p>循环变量 循环条件 循环变量的自增或者自减 都必须有<br>循环变量自增或者自减一定不能忘</p><p><strong>do-while</strong> :</p><p>循环变量 循环条件 循环变量的自增或者自减 都必须有<br>循环变量自增或者自减一定不能忘</p><h3 id="循环的解析思想"><a href="#循环的解析思想" class="headerlink" title="循环的解析思想"></a>循环的解析思想</h3><h4 id="箩筐思想求和"><a href="#箩筐思想求和" class="headerlink" title="箩筐思想求和"></a>箩筐思想求和</h4><ol><li>声明空箩筐</li><li>遍历萝卜堆数</li><li>计算萝卜总数</li></ol><h4 id="打擂思想求极值"><a href="#打擂思想求极值" class="headerlink" title="打擂思想求极值"></a>打擂思想求极值</h4><ol><li>声明一个空擂主</li><li>遍历所有的挑战者</li><li>依次和擂主PK</li></ol><h4 id="开关思想数组去重"><a href="#开关思想数组去重" class="headerlink" title="开关思想数组去重"></a>开关思想数组去重</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var arr=[10,10,20,50,20,80,60];</span><br><span class="line">var newArr=[];//声明一个空数组</span><br><span class="line">for(var i=0;i&lt;arr.length;i++)&#123;     //遍历原数组每个元素</span><br><span class="line">var isAdd=true;      //假设为真(声明一个开关)</span><br><span class="line">//判断原数组中的指定元素与新数组里面的元素是否相等</span><br><span class="line">for(var j=0;j&lt;newArr.length;j++)&#123;</span><br><span class="line">if(arr[i]==newArr[j])&#123;</span><br><span class="line">isAdd=false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//根据开关状态，来判断是否将元素添加到新数组中</span><br><span class="line">if(isAdd)&#123;</span><br><span class="line">newArr[newArr.length]=arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(newArr);</span><br></pre></td></tr></table></figure><h3 id="循环的嵌套"><a href="#循环的嵌套" class="headerlink" title="循环的嵌套"></a>循环的嵌套</h3><p>一个循环套着一个循环<br>循环嵌套中, 我们要找到外层循环变量和内层循环变量之间的关系<br>外层循环决定行, 内层循环决定列</p><h3 id="break和continue关键字"><a href="#break和continue关键字" class="headerlink" title="break和continue关键字"></a>break和continue关键字</h3><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>适用范围 : 只能用于switch语句和循环语句里<br>作用 : switch里面 结束switch语句<br>循化里面 结束当前循环语句</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>使用范围 : 只能用于循环语句<br>作用 : 结束当前这次循环, 直接进行下一轮循环<br>continue使用注意 : continue结束本次循环, 本次循环里, continue以后的语句都不执行</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM，全称Document Object Model文档对象模型。<br>JS中通过DOM来对HTML文档进行操作。只要理解了DOM就可以随心所欲的操作WEB页面。</p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>-文档表示的就是整个的HTML网页文档</p><h4 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h4><p>-对象表示将网页中的每一个部分都转换为了一个对象。</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>-使用模型来表示对象之间的关系，这样方便我们获取对象。</p><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>Node——构成HTML文档最基本的单元。</p><h5 id="常用节点"><a href="#常用节点" class="headerlink" title="常用节点"></a>常用节点</h5><p>分为四类<br>-文档节点：整个HTML文档<br>-元素节点：HTML文档中的HTML标签<br>-属性节点：元素的属性<br>-文本节点：HTML标签中的文本内容</p><h5 id="节点的三要素"><a href="#节点的三要素" class="headerlink" title="节点的三要素"></a>节点的三要素</h5><p>节点的类型：nodeType<br>节点的名称：nodeName<br>节点值：nodeValue</p><h6 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeType：1</span><br><span class="line">nodeName：标签名的大写</span><br><span class="line">nodeValue：null</span><br></pre></td></tr></table></figure><h6 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeType：2</span><br><span class="line">nodeName：属性名</span><br><span class="line">nodeValue：属性值</span><br></pre></td></tr></table></figure><h6 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeType：3</span><br><span class="line">nodeName：#text</span><br><span class="line">nodeValue：文本内容</span><br></pre></td></tr></table></figure><h6 id="注释节点"><a href="#注释节点" class="headerlink" title="注释节点"></a>注释节点</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeType：8</span><br><span class="line">nodeName：#comment</span><br><span class="line">nodeValue：注释内容</span><br></pre></td></tr></table></figure><h6 id="文档节点"><a href="#文档节点" class="headerlink" title="文档节点"></a>文档节点</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeType：9</span><br><span class="line">nodeName：#document</span><br><span class="line">nodeValue：null</span><br></pre></td></tr></table></figure><h4 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a><strong>attribute</strong></h4><p>获取属性节点要用<strong>attribute</strong></p><p><code>console.log(box.attributes);</code>获取的是元素属性的一个数组</p><h4 id="通过JS修改元素的样式"><a href="#通过JS修改元素的样式" class="headerlink" title="通过JS修改元素的样式"></a>通过JS修改元素的样式</h4><p><code>语法：元素.style.样式名=样式值</code></p><h4 id="通过JS读取元素的样式"><a href="#通过JS读取元素的样式" class="headerlink" title="通过JS读取元素的样式"></a>通过JS读取元素的样式</h4><p><code>语法：元素.style.样式名</code></p><p>通过style属性设置和读取的都是内联样式<br>无法读取样式表中的样式</p><p>注意：<br>如果CSS的样式名中含有 - ，<br>这种名称在JS中是不合法的比如background-color需要将这种样式名修改为驼峰命名法，<br>去掉 - ，然后将 - 后的第一个字母大写，backgroundColor</p><p>我们通过style属性设置的样式都是内联样式，<br>而内联样式有较高的优先级，所以通过JS修改的样式往往会立即显示<br>但是如果在样式中写了！important，则此时样式会有最高的优先级，<br>即使通过JS也不能覆盖该样式，此时将会导致JS修改样式失效所以尽量不要为样式添加！important</p><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><h5 id="获取子元素"><a href="#获取子元素" class="headerlink" title="获取子元素"></a>获取子元素</h5><p>获取子元素：<strong>父元素.children</strong><br>谷歌火狐：获取到的是元素节点<br>IE8及以下版本：获取到的是注释和元素</p><h5 id="获取兄弟元素"><a href="#获取兄弟元素" class="headerlink" title="获取兄弟元素"></a>获取兄弟元素</h5><p>上一个元素 :<strong>previousElementSibling</strong><br>下一个元素 :<strong>nextElementSibling</strong></p><p>IE8不支持获取兄弟元素的操作, 执行得到的undefined, 而且 在IE8里面没有任何替代方案<br>IE8要获取兄弟元素 只能通过节点获取</p><p>获取上一个兄弟元素的封装<br>@param ele : 需要查找的目标参数<br>@return node : 返回的是一个元素节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function getPreviousElement(ele) &#123;</span><br><span class="line">    // 能力检测</span><br><span class="line">    if(ele.previousElementSibling)  &#123;  // 谷歌火狐</span><br><span class="line">        return ele.previousElementSibling;</span><br><span class="line">    &#125; else &#123;  // IE8</span><br><span class="line">        // 获取上一个节点  :  null  元素  文本  注释</span><br><span class="line">        var node = ele.previousSibling;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">  // 循环次数不确定</span><br><span class="line">  // 1. node必须存在, 不是null,  2. node不是元素节点</span><br><span class="line">  while(node != null &amp;&amp; node.nodeType != 1) &#123;</span><br><span class="line">     node =  node.previousSibling</span><br><span class="line">  &#125;</span><br><span class="line">  // node == null  或者  node.nodeType == 1</span><br><span class="line">  return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getPreviousElement(li2));</span><br></pre></td></tr></table></figure><p>获取下一个元素的兼容性封装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  function getNextElement(ele) &#123;</span><br><span class="line">        // 能力检测</span><br><span class="line">        if(ele.nextElementSibling)  &#123;  // 谷歌火狐</span><br><span class="line">            return ele.nextElementSibling;</span><br><span class="line">        &#125; else &#123;  // IE8</span><br><span class="line">            // 获取下一个节点  :  null  元素  文本  注释</span><br><span class="line">            var node = ele.nextSibling;</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">      // 循环次数不确定</span><br><span class="line">      // 1. node必须存在, 不是null,  2. node不是元素节点</span><br><span class="line">      while(node  &amp;&amp; node.nodeType != 1) &#123;</span><br><span class="line">         node =  node.nextSibling</span><br><span class="line">      &#125;</span><br><span class="line">      // node == null  或者  node.nodeType == 1</span><br><span class="line">      return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getNextElement(li3));</span><br></pre></td></tr></table></figure><h5 id="获取第一个子元素"><a href="#获取第一个子元素" class="headerlink" title="获取第一个子元素"></a>获取第一个子元素</h5><p><strong>父元素.firstElementChild</strong></p><p>IE8无法执行元素的操作<br>获取第一个子元素的兼容型封装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getFirstElementChild(ele)&#123;</span><br><span class="line"> // 能力检测</span><br><span class="line">  if(ele.firstElementChild != undefined)&#123;// 谷歌火狐</span><br><span class="line">        return ele.firstElementChild;</span><br><span class="line">  &#125;else&#123;// IE8</span><br><span class="line">    // 第一个子节点  :  null  元素  文本  注释</span><br><span class="line">        var nodeFirst = ele.firstChild;</span><br><span class="line">// 循环次数不确定</span><br><span class="line">// 1.  nodeFirst必须存在, 不是null,  2.  nodeFirst不是元素节点</span><br><span class="line">        while(nodeFirst &amp;&amp; nodeFirst.nodeType != 1)&#123;</span><br><span class="line">              nodeFirst = nodeFirst.nextSibling;</span><br><span class="line">        &#125;</span><br><span class="line">//  nodeFirst == null  或者   nodeFirst.nodeType == 1</span><br><span class="line">        return nodeFirst;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取最后一个子元素"><a href="#获取最后一个子元素" class="headerlink" title="获取最后一个子元素"></a>获取最后一个子元素</h5><p> <strong>父元素.lastElementChild</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IE8兼容性的封装 获取最后一个子元素</span><br><span class="line"></span><br><span class="line">function getLastElementChild(obj)&#123;</span><br><span class="line">      if(obj.lastElementChild != undefined)&#123;</span><br><span class="line">            return obj.lastElementChild;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">            var nodeLast = obj.lastChild;</span><br><span class="line">            while(nodeLast &amp;&amp; nodeLast.nodeType != 1)&#123;</span><br><span class="line">                  nodeLast = nodeLast.previousSibling;</span><br><span class="line">            &#125;</span><br><span class="line">            return nodeLast;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取元素所有样式属性"><a href="#获取元素所有样式属性" class="headerlink" title="获取元素所有样式属性"></a>获取元素所有样式属性</h4><h5 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle"></a>getComputedStyle</h5><p>getComputedStyle:获取元素所有的样式<br>参数1:要获取样式的对象<br>参数2:伪元素,一般不传,默认为null<br>返回值:是样式对象</p><p>获取元素属性的特点：<br>1.可以获取行内 也可以获取行外<br>2.获取的是字符串，带单位<br>3.获取的元素为只读，不能修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">#box&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: pink;</span><br><span class="line">border: 10px yellow solid;</span><br><span class="line">margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line">#box::after&#123;</span><br><span class="line">background-color: red;</span><br><span class="line">width: 30px;</span><br><span class="line">height: 30px;</span><br><span class="line">content:&quot;欢迎&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;box&quot; class=&quot;one&quot;&gt;hyhhhh&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//获取元素</span><br><span class="line">var box=document.getElementById(&quot;box&quot;);</span><br><span class="line">  var boxStyle=window.getComputedStyle(box,null);</span><br><span class="line">  console.log(boxStyle);</span><br><span class="line">  console.log(boxStyle.width);//100px</span><br><span class="line">  console.log(boxStyle.fontSize);//16px</span><br><span class="line">  console.log(boxStyle.backgroundColor);//rgb(255, 192, 203)</span><br><span class="line">  boxStyle.height=&quot;100px&quot;;//报错</span><br><span class="line">  </span><br><span class="line">  var weiStyle=window.getComputedStyle(box,&quot;::after&quot;);</span><br><span class="line">  console.log(weiStyle);</span><br><span class="line">  console.log(weiStyle.backgroundColor);//rgb(255, 0, 0)</span><br><span class="line">  console.log(weiStyle.content);//&quot;欢迎&quot;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h5><p>IE8及其以下的浏览器不支持getComputedStyle方法<br>IE8使用currentStyle</p><p>作为IE8的兼容<br>@param ele 需要查询的元素<br>@param attr 需要获取到的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getEleStyle(ele,attr)&#123;</span><br><span class="line">//做浏览器能力检测</span><br><span class="line">if(window.getComputedStyle)&#123;</span><br><span class="line">var style=window.getComputedStyle(ele,null);</span><br><span class="line">return style[attr];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return ele.currentStyle[attr];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> console.log(getEleStyle(box,&quot;width&quot;));</span><br></pre></td></tr></table></figure><h4 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box1&quot;,class=&quot;one&quot;&gt;div1&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;box2&quot;,class=&quot;one&quot;&gt;div2&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;box3&quot;,class=&quot;one&quot;&gt;div3&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;www&quot; value=&quot;我是input&quot;&gt;</span><br></pre></td></tr></table></figure><h5 id="通过document对象调用"><a href="#通过document对象调用" class="headerlink" title="通过document对象调用"></a>通过document对象调用</h5><h6 id="1-getElementById"><a href="#1-getElementById" class="headerlink" title="1.getElementById()"></a>1.getElementById()</h6><p>-通过id属性获取一个元素节点对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var box1=document.getElementById(&quot;box1&quot;);</span><br></pre></td></tr></table></figure><p>id具有唯一性不要使用同名id，如果获取的id不存在结果为null</p><p>id具有唯一性不要使用同名id，如果获取的id不存在结果为null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var box4=document.getElementById(&quot;box4&quot;);//null</span><br></pre></td></tr></table></figure><h6 id="2-getElementsByTagName-）"><a href="#2-getElementsByTagName-）" class="headerlink" title="2.getElementsByTagName(）"></a>2.getElementsByTagName(）</h6><p>-通过标签名获取一组元素节点对象<br>获取到的是一个伪数组</p><p>2.getElementsByTagName(）<br>-通过标签名获取一组元素节点对象<br>获取到的是一个伪数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var divs=document.getElementsByTagName(&quot;div&quot;);</span><br></pre></td></tr></table></figure><h6 id="3-getElementsByName-）"><a href="#3-getElementsByName-）" class="headerlink" title="3.getElementsByName(）"></a>3.getElementsByName(）</h6><p>-通过name属性获取一组元素节点对象<br>获取到的是一个伪数组且只适用于拥有name属性的表单元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var www=document.getElementsByName(&quot;www&quot;);</span><br></pre></td></tr></table></figure><h4 id="获取元素节点的子节点"><a href="#获取元素节点的子节点" class="headerlink" title="获取元素节点的子节点"></a>获取元素节点的子节点</h4><h5 id="通过具体的元素节点调用"><a href="#通过具体的元素节点调用" class="headerlink" title="通过具体的元素节点调用"></a>通过具体的元素节点调用</h5><h6 id="1-getElementsByTagName-）"><a href="#1-getElementsByTagName-）" class="headerlink" title="1.getElementsByTagName(）"></a>1.getElementsByTagName(）</h6><p>-方法，返回当前节点的指定标签名后代节点</p><h6 id="2-childNodes"><a href="#2-childNodes" class="headerlink" title="2.childNodes"></a>2.childNodes</h6><p>-属性，表示当前节点的所有子节点<br>childNodes属性会获取包括文本节点在内的所有节点<br>根据DOM规定，标签间空白也会当成文本节点</p><p>获取元素的所有子节点（文本、注释、元素）<br>在谷歌火狐中获取的是：文本（包括空文本（不可见字符））、注释、元素<br>在IE8及以下版本获取的是：文本（不包括空文本）、注释、元素</p><p>注意：<br>在IE8及以下的浏览器中，不会将空白文本当成子节点，<br>所以该属性在IE8中会返回4个子元素而其他浏览器是9个</p><p>children属性可以获取当前元素的所有子元素</p><h6 id="3-firstChild"><a href="#3-firstChild" class="headerlink" title="3.firstChild"></a>3.firstChild</h6><p>-属性，表示当前节点的第一个子节点<br>根据DOM规定，标签间空白也会当成文本节点<br>firstElementChild获取当前元素的第一个子元素<br>firstElementChild不支持IE8及以下的浏览器，如果需要兼容他们尽量不要使用</p><h6 id="4-lastChild"><a href="#4-lastChild" class="headerlink" title="4.lastChild"></a>4.lastChild</h6><p>-属性，表示当前节点的最后一个子节点<br>根据DOM规定，标签间空白也会当成文本节点<br>lastElementChild获取当前元素的最后一个子元素<br>lastElementChild不支持IE8及以下的浏览器，如果需要兼容他们尽量不要使用</p><h4 id="获取父节点和兄弟节点"><a href="#获取父节点和兄弟节点" class="headerlink" title="获取父节点和兄弟节点"></a>获取父节点和兄弟节点</h4><h5 id="通过具体的节点调用"><a href="#通过具体的节点调用" class="headerlink" title="通过具体的节点调用"></a>通过具体的节点调用</h5><h6 id="1-parentNode"><a href="#1-parentNode" class="headerlink" title="1.parentNode"></a>1.parentNode</h6><p>-属性，表示当前节点的父节点</p><h6 id="2-previousSibling"><a href="#2-previousSibling" class="headerlink" title="2.previousSibling"></a>2.previousSibling</h6><p>（也可能获取到空白的文本）<br>-属性，表示当前节点的前一个兄弟节点</p><h6 id="3-nextSibling"><a href="#3-nextSibling" class="headerlink" title="3.nextSibling"></a>3.nextSibling</h6><p>（也可能获取到空白的文本）<br>-属性，表示当前节点的后一个兄弟节点</p><p>previousElementSibling获取前一个兄弟元素，IE8及以下不支持</p><h4 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h4><p><strong>元素.cloneNode(参数)</strong><br>参数 : 布尔类型 true false(默认)</p><ol><li>克隆节点只会在内存中克隆一份,  不会添加到页面上  只能手动添加</li></ol><p>2.克隆会把id也克隆过去</p><p>3.添加子元素到页面中(父元素中)   父元素.appendChild(子元素)</p><h4 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h4><p>-该属性可以获取到元素内部的文本内容<br>-它和innerHTML类似，不同的是它会自动将html标签去除</p><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p>文本框的value属性值，就是文本框中填写的内容</p><h4 id="document-body"><a href="#document-body" class="headerlink" title="document.body"></a>document.body</h4><p>它保存的是body的引用</p><h4 id="document-documentElement"><a href="#document-documentElement" class="headerlink" title="document.documentElement"></a>document.documentElement</h4><p>保存的是html根标签</p><h4 id="document-all"><a href="#document-all" class="headerlink" title="document.all"></a>document.all</h4><p>代表页面中所有的元素</p><p>根据元素的class属性值查询一组元素节点对象</p><h4 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h4><p>可以根据class属性值获取一组元素节点对象，<br>但是该方法不支持IE8及以下的浏览器<br>获取到的是一个伪数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var one=document.getElementsByClassName(&quot;one&quot;);</span><br></pre></td></tr></table></figure><h4 id="document-querySelector"><a href="#document-querySelector" class="headerlink" title="document.querySelector()"></a>document.querySelector()</h4><p>-需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象<br>-虽然IE8中没有getElementsByClassName()但是可以使用**querySelector()**代替<br>-使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var one=document.querySelector(&quot;one&quot;);</span><br></pre></td></tr></table></figure><h4 id="document-querySelectorAll"><a href="#document-querySelectorAll" class="headerlink" title="document.querySelectorAll()"></a>document.querySelectorAll()</h4><p>-该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回<br>-即使符合条件的元素只有一个，它也会返回数组<br>参数为对应的选择器和名字</p><p>document.querySelectorAll()<br>-该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回<br>-即使符合条件的元素只有一个，它也会返回数组<br>参数为对应的选择器和名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var onelist=document.querySelector(&quot;.one&quot;);</span><br></pre></td></tr></table></figure><p>注意：<br>获取到的是一个伪数组，要在后面加上[下标(索引)]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var one=document.getElementsByClassName(“one”)[0];</span><br></pre></td></tr></table></figure><p>或在取值时加上[下标(索引)]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(one[0].id)</span><br></pre></td></tr></table></figure><p>或在取值时加上[下标(索引)]<br>console.log(one[0].id)</p><h4 id="元素的取值和赋值"><a href="#元素的取值和赋值" class="headerlink" title="元素的取值和赋值"></a>元素的取值和赋值</h4><p>对象名.属性名<br>对象名[“属性名”]<br>console.log(one.id);<br>console.log(one[“id”]);<br>通过JS读取元素的样式：<br>语法：元素.style.样式名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one.style</span><br><span class="line">one.style.width</span><br><span class="line">one.style.backgroundColor</span><br></pre></td></tr></table></figure><h4 id="通过JS修改元素的样式-1"><a href="#通过JS修改元素的样式-1" class="headerlink" title="通过JS修改元素的样式"></a>通过JS修改元素的样式</h4><p>语法：元素.style.样式名&#x3D;样式值</p><p>通过JS修改元素的样式：<br>语法：元素.style.样式名&#x3D;样式值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one.style.backgroundColor=&quot;green&quot;</span><br><span class="line">one.style.color=&quot;red&quot;</span><br></pre></td></tr></table></figure><p>通过style属性设置和读取的都是内联样式<br>无法读取样式表中的样式</p><p>通过style属性设置和读取的都是内联样式<br>无法读取样式表中的样式</p><p>获取类名，不能直接使用class，而是className</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one.className</span><br></pre></td></tr></table></figure><h4 id="DOM增删改"><a href="#DOM增删改" class="headerlink" title="DOM增删改"></a>DOM增删改</h4><h5 id="document-createElement（）"><a href="#document-createElement（）" class="headerlink" title="document.createElement（）"></a>document.createElement（）</h5><p>可以用于创建一个元素节点对象，<br>它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，<br>并将创建好的对象作为返回值返回</p><p>DOM增删改<br>document.createElement（）<br>可以用于创建一个元素节点对象，<br>它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，<br>并将创建好的对象作为返回值返回</p><h5 id="document-createTextNode（）"><a href="#document-createTextNode（）" class="headerlink" title="document.createTextNode（）"></a>document.createTextNode（）</h5><p>可以用来创建一个文本节点对象<br>需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回</p><h5 id="appendChild（）"><a href="#appendChild（）" class="headerlink" title="appendChild（）"></a>appendChild（）</h5><p>-向一个父节点中添加一个新的子节点<br>-用法：父节点.appendChild（子节点）；</p><h5 id="insertBefore（）"><a href="#insertBefore（）" class="headerlink" title="insertBefore（）"></a>insertBefore（）</h5><p>-可以在指定的子节点前插入新的子节点<br>-语法：父节点.insertBefore（要插入的节点对象，要添加新的节点前的子节点）；</p><h5 id="replaceChild（）"><a href="#replaceChild（）" class="headerlink" title="replaceChild（）"></a>replaceChild（）</h5><p>-可以使用指定的子节点替换已有的子节点<br>-语法：父节点.replaceChild（要插入的节点对象，要添加新的节点前的子节点）；</p><h5 id="removeChild（）"><a href="#removeChild（）" class="headerlink" title="removeChild（）"></a>removeChild（）</h5><p>-可以删除一个子节点<br>-语法：父节点.removeChild（子节点）；<br>另一种删除方法<br>-子节点.parentNode.removeChild（子节点）；</p><p>使用innerHTML也可以完成DOM的增删改的相关操作<br>一般我们会两种方式结合使用</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件三要素 :<br>事件源 : 什么元素<br>事件类型 : 什么时候<br>事件处理 : 做什么事 (函数)</p><p>交互 : 哪个元素在什么时候做什么事<br>事件 : js用来处理用户交互的机制<br>元素注册事件的本质 : 就是给对象属性赋值<br>语法结构 : 事件源.事件类型 &#x3D; 事件处理函数<br>事件的工作原理 :</p><p>当元素注册事件的时候, 事件处理函数不会执行<br>当用户触发事件的时候, 浏览器就会捕捉事件源(执行事件处理函数)<br>onclick 在点击的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box.onclick = function() &#123;</span><br><span class="line">    console.log(111);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件分类-事件类型"><a href="#事件分类-事件类型" class="headerlink" title="事件分类(事件类型)"></a>事件分类(事件类型)</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>事件分类(事件类型)<br>鼠标事件</p><p>click : 点击事件<br>dbclick : 双击 (300ms以内连续发生两次点击事件)<br>mouseover : 鼠标进入<br>mouseout : 鼠标滑出<br>mouseenter : 鼠标进入<br>mouseleave : 鼠标离开<br>mousedown : 鼠标按下(左键)<br>mouseup : 鼠标弹起<br>mousewheel : 鼠标滚轮滚动</p><p>mouseover和mouseenter的区别：<br>mouseover：只要鼠标指针移入事件所绑定的元素或其子元素，都会触发该事件<br>mouseenter：只有鼠标移入时间所绑定的元素时，才会触发该事件<br>如果一个元素没有子元素，那么该元素绑定mouseover和mouseenter效果没有区别<br>如果绑定了mouseover的元素存在子元素不管鼠标移入该元素还是该元素的子元素都会触发该事件</p><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>keyup : 键盘抬起<br>keydown : 键盘按下<br>keypress : 键盘按下 (按下去和弹起来两个过程)</p><h4 id="表单元素常用的事件"><a href="#表单元素常用的事件" class="headerlink" title="表单元素常用的事件"></a>表单元素常用的事件</h4><p>blur : 失去焦点<br>focus : 获取焦点事件<br>change : 内容改变事件<br>select : 被选中事件</p><h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p>load：页面加载完毕执行<br>error：捕获网页中的错误<br>scroll：元素滚动时执行<br>resize：浏览器窗口被调整大小执行</p><h3 id="事件的注册方式"><a href="#事件的注册方式" class="headerlink" title="事件的注册方式"></a>事件的注册方式</h3><h4 id="直接在DOM元素中注册-html事件"><a href="#直接在DOM元素中注册-html事件" class="headerlink" title="直接在DOM元素中注册(html事件)"></a>直接在DOM元素中注册(html事件)</h4><p>直接在html标签通过on+事件类型 &#x3D; “function() {} “来绑定事件<br>缺点 : 结构混合在一起</p><p>在js代码中直接绑定 (dom0级事件)<br>先在js代码中获取元素, 使用点语法注册<br>缺点 : 就是不能重复注册同名事件, 否则就会覆盖, 默认冒泡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one.onclick = function() &#123;</span><br><span class="line">              console.log(123);</span><br><span class="line">              one.style.backgroundColor = &quot;red&quot;;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><h4 id="使用事件监听函数绑定事件-dom2级事件"><a href="#使用事件监听函数绑定事件-dom2级事件" class="headerlink" title="使用事件监听函数绑定事件(dom2级事件)"></a>使用事件监听函数绑定事件(dom2级事件)</h4><h5 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h5><p>事件对象<br>当用户触发某个事件的时候, 浏览器会捕捉到与触发事件相关的一些信息<br>获取事件对象 : 谷歌火狐 : e, ev, event, 但是在IE8及其以下版本浏览器里面, 不需要形参, 直接使用全局变量 window.event;<br>兼容的方法：</p><p>使用事件监听函数绑定事件(dom2级事件)<br>addEventListener<br>事件对象<br>当用户触发某个事件的时候, 浏览器会捕捉到与触发事件相关的一些信息<br>获取事件对象 : 谷歌火狐 : e, ev, event, 但是在IE8及其以下版本浏览器里面, 不需要形参, 直接使用全局变量 window.event;<br>兼容的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function(e) &#123;</span><br><span class="line">            e = e || window.event;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">  var box = document.getElementById(&quot;box&quot;);</span><br><span class="line">        box.onclick = function(e) &#123;</span><br><span class="line">            e = e || window.event;</span><br><span class="line">            console.log(e);</span><br><span class="line">            alert(123);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="addEventListener-1"><a href="#addEventListener-1" class="headerlink" title="addEventListener"></a>addEventListener</h5><p>点语法注册事件的缺点 : 注册多个同名事件, 后者会覆盖前者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box.onclick = function() &#123;</span><br><span class="line">       alert(&quot;你好&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><pre><code>box.onclick = function() &#123;   alert(&quot;今天天气真好&quot;)&#125;//覆盖前面的</code></pre><p>使用addEventListener来注册事件 不会覆盖, 而是一次触发</p><h5 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h5><p>type : 事件类型 不要on (click mouseover mouseenter)<br>listener : 事件处理函数<br>布尔类型 默认是false, 不传时false<br>false表示冒泡 true表示捕获</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">console.log(this);       </span><br><span class="line">  alert(888);</span><br><span class="line"> &#125;</span><br><span class="line"> box.addEventListener(&quot;click&quot;, fun, false)</span><br><span class="line"></span><br><span class="line"> box.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">    alert(999);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="IE8注册事件"><a href="#IE8注册事件" class="headerlink" title="IE8注册事件"></a>IE8注册事件</h5><p>不支持addEventListener 使用attachEvent()<br>attachEvent只有两个参数<br>type :事件类型 这里必须加on (onclick, onmouseover)<br>listener : 事件处理函数</p><p>IE8注册事件 不支持addEventListener 使用attachEvent()<br>attachEvent只有两个参数<br>type :事件类型 这里必须加on (onclick, onmouseover)<br>listener : 事件处理函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">console.log(this);       </span><br><span class="line">  alert(888);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">box.attachEvent(&quot;onclick&quot;, fun);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">box.attachEvent(&quot;onclick&quot;, function() &#123;</span><br><span class="line">    alert(999);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>谷歌火狐和IE8的兼容</p><p>谷歌火狐和IE8的兼容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function addEvent(ele, type, fun) &#123; // 这里默认不加on</span><br><span class="line">       if(ele.addEventListener) &#123;  // 谷歌火狐</span><br><span class="line">           ele.addEventListener(type, fun )</span><br><span class="line">       &#125; else if(ele.attachEvent) &#123; // IE8及以下的</span><br><span class="line">           ele.attachEvent(&quot;on&quot; + type, fun)</span><br><span class="line">       &#125; else &#123;  // 其他浏览器</span><br><span class="line">           ele[&quot;on&quot; + type] = fun;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>innerText、textContent和innerHTML<br>innerText 获取元素文本(包含子元素的文本) 但是innerText不是W3C的标准语法 而是微软的自己的语法<br>火狐42版本以前的版本不支持<br>textContent 作用和innerText完全一致 只是浏览器兼容性不同<br>textContent 是W3C的标准语法 但是微软IE8及以前浏览器不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt; 我是div标签</span><br><span class="line">        &lt;p&gt;我是一个p标签&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var box =document.getElementById(&quot;box&quot;);</span><br><span class="line"></span><br><span class="line">console.log(box.innerText);</span><br><span class="line">console.log(box.textContent);</span><br><span class="line">console.log(box.innerHTML);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="innerText-和innerHTML的区别"><a href="#innerText-和innerHTML的区别" class="headerlink" title="innerText 和innerHTML的区别"></a>innerText 和innerHTML的区别</h4><p>innerText : 无法识别标签, 会把所有的内容都设置成元素的文本<br>innerHTML : 可以识别内容中的标签, 并进行解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.innerText = &quot;&lt;a&gt;我是一个a标签&lt;/a&gt;&lt;p&gt;我是一个p标签&lt;/p&gt;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.innerHTML = &quot;&lt;a&gt;我是一个a标签&lt;/a&gt;&lt;p&gt;我是一个p标签&lt;/p&gt;&quot;</span><br></pre></td></tr></table></figure><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>事件冒泡 : 当一个元素的事件被触发时, 这个元素所有的父元素的同名事件就会被依次触发<br>元素 –&gt; 父元素 –&gt; body –&gt; html –&gt; document –&gt; window<br>事件冒泡一直存在 只是我们以前没有给父元素注册同名事件</p> <div id="box">        <input type="button" value="点我呀" id="btn">        <div id="son">我是子元素</div>    </div><pre><code>&lt;script&gt;     document.getElementById(&quot;box&quot;).onclick = function() &#123;        alert(&quot;我是父盒子&quot;)    &#125;;    document.getElementById(&quot;btn&quot;).onclick = function() &#123;        alert(&quot;我是小按钮&quot;)    &#125;;    document.getElementById(&quot;son&quot;).onclick = function() &#123;        alert(&quot;我是小盒子&quot;)    &#125;;     document.body.onclick = function() &#123;        alert(&quot;我是body&quot;)    &#125;;     document.documentElement.onclick = function() &#123;        alert(&quot;我是html&quot;)    &#125;;     document.onclick = function() &#123;        alert(&quot;我是document&quot;)    &#125;;     window.onclick = function() &#123;        alert(&quot;我是window&quot;)    &#125;;&lt;/script&gt;</code></pre><h5 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h5><p>阻止事件冒泡, 要先获取事件对象<br><strong>e.stopPropagation();</strong> 谷歌火狐阻止事件冒泡的方法<br><strong>e.cancelBubble &#x3D; true;</strong> IE8及以前版本浏览器阻止冒泡的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;box&quot;).onclick = function() &#123;</span><br><span class="line">            alert(&quot;我是父盒子&quot;)</span><br><span class="line">        &#125;;</span><br><span class="line">        document.getElementById(&quot;btn&quot;).onclick = function() &#123;</span><br><span class="line">            alert(&quot;我是小按钮&quot;)</span><br><span class="line">        &#125;;</span><br><span class="line">        document.getElementById(&quot;son&quot;).onclick = function() &#123;</span><br><span class="line">            alert(&quot;我是小盒子&quot;)</span><br><span class="line">        &#125;;</span><br><span class="line">         document.body.onclick = function(e) &#123;</span><br><span class="line">            //  console.log(e);</span><br><span class="line">             e = e || window.event;</span><br><span class="line">            alert(&quot;我是body&quot;)</span><br><span class="line">            // 阻止事件冒泡, 要先获取事件对象</span><br><span class="line">            // e.stopPropagation();  // 谷歌火狐阻止事件冒泡的方法</span><br><span class="line">            e.cancelBubble = true;  // IE8及以前版本浏览器阻止冒泡的方法</span><br><span class="line">        &#125;;</span><br><span class="line">         document.documentElement.onclick = function() &#123;</span><br><span class="line">            alert(&quot;我是html&quot;)</span><br><span class="line">        &#125;;</span><br><span class="line">         document.onclick = function() &#123;</span><br><span class="line">            alert(&quot;我是document&quot;)</span><br><span class="line">        &#125;;</span><br><span class="line">         window.onclick = function() &#123;</span><br><span class="line">            alert(&quot;我是window&quot;)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>事件捕获 : 当一个元素的事件被触发, 先从最顶级的父元素往下依次触发, 直到目标元素<br>window –&gt; document –&gt; html –&gt; body –&gt; 父元素 –&gt; 目标元素<br><strong>e.stopPropagation();</strong> 也可以用来阻止事件捕获</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;button&quot; value=&quot;点我呀&quot; id=&quot;btn&quot; /&gt;</span><br><span class="line">      &lt;div id=&quot;son&quot;&gt;我是子元素&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">document.getElementById(&quot;btn&quot;).addEventListener(</span><br><span class="line">        &quot;click&quot;,</span><br><span class="line">        function() &#123;</span><br><span class="line">          alert(&quot;我是小按钮&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        true</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      document.getElementById(&quot;box&quot;).addEventListener(</span><br><span class="line">        &quot;click&quot;,</span><br><span class="line">        function() &#123;</span><br><span class="line">          alert(&quot;我是父盒子&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        true</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      document.getElementById(&quot;son&quot;).addEventListener(</span><br><span class="line">        &quot;click&quot;,</span><br><span class="line">        function() &#123;</span><br><span class="line">          alert(&quot;我是子盒子&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        true</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      document.body.addEventListener(</span><br><span class="line">        &quot;click&quot;,</span><br><span class="line">        function(e) &#123;</span><br><span class="line">          alert(&quot;我是body&quot;);</span><br><span class="line"></span><br><span class="line">          e = e || window.event;</span><br><span class="line">          e.stopPropagation();  // 也可以用来阻止事件捕获</span><br><span class="line">          </span><br><span class="line">        &#125;,</span><br><span class="line">        true</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      document.documentElement.addEventListener(</span><br><span class="line">        &quot;click&quot;,</span><br><span class="line">        function() &#123;</span><br><span class="line">          alert(&quot;我是html&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        true</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      document.addEventListener(</span><br><span class="line">        &quot;click&quot;,</span><br><span class="line">        function() &#123;</span><br><span class="line">          alert(&quot;我是document&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        true</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      window.addEventListener(</span><br><span class="line">        &quot;click&quot;,</span><br><span class="line">        function() &#123;</span><br><span class="line">          alert(&quot;我是window&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        true</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h6><p><strong>事件冒泡和事件捕获同时存在事件捕获会先执行</strong></p><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="常见的BOM对象"><a href="#常见的BOM对象" class="headerlink" title="常见的BOM对象"></a>常见的BOM对象</h3><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p>代表整个浏览器窗口（window是BOM中的一个对象，并且是顶级的对象）</p><h5 id="window对象的介绍与使用"><a href="#window对象的介绍与使用" class="headerlink" title="window对象的介绍与使用"></a>window对象的介绍与使用</h5><p>window对象:浏览器窗口<br>BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过javascript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。</p><p>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。<br>全局变量是 window 对象的属性。<br>全局函数是 window 对象的方法。</p><p>特点：<br>1.对于全局变量或者全局方法，在取值或者调用时，可以省略window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a=12;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(window.a);</span><br><span class="line">console.log(window);</span><br><span class="line">console.log(window.a==a);//true</span><br><span class="line">   </span><br><span class="line">//alert(123);//window.alert(123);</span><br></pre></td></tr></table></figure><p>2.window对象是js中的顶级对象（所有的全局变量 全局函数 包括document 都是window属性）</p><p>2.window对象是js中的顶级对象（所有的全局变量 全局函数 包括document 都是window属性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(document.body);</span><br><span class="line">console.log(window.document.body);</span><br></pre></td></tr></table></figure><p>3.window对象有一个默认的属性name，而且name的值只能是字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(age);//报错  因为没有定义</span><br><span class="line">console.log(name);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//window对象有一个默认的属性name，而且name的值只能是字符串</span><br><span class="line">window.name=10;</span><br><span class="line">console.log(name);</span><br><span class="line">name=[12,34,25];</span><br><span class="line">console.log(name);</span><br></pre></td></tr></table></figure><p>4.top属性是只读性质的 无法修改,返回最顶层的父窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(top);</span><br><span class="line">var top=&quot;123&quot;;</span><br><span class="line">console.log(top);</span><br></pre></td></tr></table></figure><p>top 返回最顶层的父窗口。<br>语法</p><p>top 返回最顶层的父窗口。<br>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.top</span><br></pre></td></tr></table></figure><h5 id="window对象中的两个方法"><a href="#window对象中的两个方法" class="headerlink" title="window对象中的两个方法"></a>window对象中的两个方法</h5><h6 id="打开窗口：open"><a href="#打开窗口：open" class="headerlink" title="打开窗口：open"></a>打开窗口：<strong>open</strong></h6><p>打开窗口<br>语法：window.open()<br>参数：<br>@param url ：网址，要载入窗体的URL</p><p>@param name：新建窗体的名称(目标,将在a 标签的target属性中用到，当与已有窗体名称相同时将覆盖窗体内容).open函数默认的打开窗体的方式为target的 _ blank弹出方式，因此页面都将以弹出的方式打开<br>两个值：<br>1._ self 在本页面直接打开<br>2._blank 在新的标签页打开（此为默认值）</p><p>@param featrues：特征 设置新窗口的大小位置等特征，字符串组成，字符串中每个特性使用逗号分隔</p><p>@param replace：可选的布尔值，规定了装载到窗口的URL是在窗口的浏览历史中创建一个新条目<br>还是替换浏览历史中的当前条目，就是说明新载入的页面是否替换当前载入的页面，此参数通常不用指定<br>true：URL替换浏览历史中的当前条目。<br>false：URL在浏览历史中创建新的条目。</p><h6 id="关闭窗口：close"><a href="#关闭窗口：close" class="headerlink" title="关闭窗口：close"></a>关闭窗口：<strong>close</strong></h6><p>语法：<strong>window.close()</strong><br>是想关闭哪个窗口，就使用哪个窗口去调用<strong>close</strong>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var myWindow;</span><br><span class="line">   document.getElementById(&quot;open&quot;).onclick=function()&#123;  </span><br><span class="line"> myWindow = window.open(&quot;http://www.baidu.com&quot;,&quot;_self&quot;,&quot;left=100px,top=100px,width=200px,height=200px&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   document.getElementById(&quot;close&quot;).onclick=function()&#123;</span><br><span class="line">   myWindow.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="window里的三个事件"><a href="#window里的三个事件" class="headerlink" title="window里的三个事件"></a>window里的三个事件</h5><h6 id="1-onload"><a href="#1-onload" class="headerlink" title="1.onload"></a>1.onload</h6><p>事件会在页面或图像加载完成后立即发生。</p><p>onload 通常用于 body元素，在页面完全载入后(包括图片、css文件等等。)执行脚本代码。<br>作用：可以在页面任意位置获取到dom元素</p><p>为什么使用 window.onload()<br>JavaScript 中的函数方法需要在 HTML 文档渲染完成后才可以使用，如果没有渲染完成，此时的 DOM 树是不完整的，这样在调用一些 JavaScript 代码时就可能报出”undefined”错误。</p><h6 id="2-onbeforeunload"><a href="#2-onbeforeunload" class="headerlink" title="2..onbeforeunload"></a>2..onbeforeunload</h6><p>在页面即将要关闭的前一时刻</p><p>作用：挽留用户，onbeforeunload 事件在即将离开当前页面（刷新或关闭）时触发。<br>该事件可用于弹出对话框，提示用户是继续浏览页面还是离开当前页面。<br>对话框默认的提示信息根据不同的浏览器有所不同，标准的信息类似 “确定要离开此页吗？”。<br>该信息不能删除。但你可以自定义一些消息提示与标准信息一起显示在对话框。</p><p>注意： 如果你没有在 body 元素上指定 onbeforeunload 事件，则需要在 window 对象上添加事件，并使用 returnValue 属性创建自定义信息。<br>在 Firefox 浏览器中，只显示默认提醒信息（不显示自定义信息）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.onbeforeunload=function()&#123; console.log(&quot;页面即将关闭&quot;); return &quot;您确定离开吗？&quot; &#125;</span><br></pre></td></tr></table></figure><h6 id="3-onunload"><a href="#3-onunload" class="headerlink" title="3.onunload"></a>3.onunload</h6><p>页面正在关闭 无法做任何事</p><p>onunload 事件在用户退出页面时发生。<br>onunload 发生于当用户离开页面时发生的事件(通过点击一个连接，提交表单，关闭浏览器窗口等等。)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.onunload=function()&#123; alert(&quot;页面正在关闭&quot;); &#125;</span><br></pre></td></tr></table></figure><h4 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h4><p>代表浏览器当前的信息，通过Navigator我们可以获取用户当前使用的是什么浏览器</p><h5 id="用Navigator判断浏览器的封装"><a href="#用Navigator判断浏览器的封装" class="headerlink" title="用Navigator判断浏览器的封装"></a>用Navigator判断浏览器的封装</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(window.navigator);</span><br><span class="line">if(navigator.userAgent.indexOf(&quot;Chrome&quot;)!=-1)&#123;</span><br><span class="line">alert(&quot;谷歌浏览器&quot;);</span><br><span class="line">&#125;else if(navigator.userAgent.indexOf(&quot;Firefox&quot;)!=-1)&#123;</span><br><span class="line">alert(&quot;火狐浏览器&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">alert(&quot;其他浏览器&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(screen);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><p>代表用户的屏幕信息</p><h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><p>代表浏览器的历史信息，通过History我们可以实现上一步&#x2F;刷新&#x2F;下一步操作（出于<br>对用户的隐私考虑，我们只能拿到当前的浏览记录，不能拿到所有的历史记录）</p><p>History 对象属性<br><strong>length</strong> 返回历史列表中的网址数<br>语法：<strong>history.length</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write(&quot;历史列表中URL的数量： &quot; + history.length);</span><br></pre></td></tr></table></figure><h5 id="History-对象方法"><a href="#History-对象方法" class="headerlink" title="History 对象方法"></a>History 对象方法</h5><p><strong>back()</strong>:上一步<br><strong>forward()</strong>:下一步<br>如果是新打开的页面，没有发生过跳转，那么 forward是无效的<br><strong>go()</strong> ：加载 history 列表中的某个具体页面<br>语法：<strong>history.go(number|URL)</strong></p><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>代表浏览器当前的地址信息，通过Location我们可以获取或者设置当前的地址信息,用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。在编写时可不使用 window这个前缀。</p><h5 id="url"><a href="#url" class="headerlink" title="url"></a>url</h5><p>全球统一资源定位符<br>http&#x2F;&#x2F;<a href="http://www.baidu.com/">www.baidu.com/</a> 路径&#x2F;参数</p><h5 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h5><p>协议名 http&#x2F;https</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(location.protocol);</span><br></pre></td></tr></table></figure><h5 id="host"><a href="#host" class="headerlink" title="host"></a>host</h5><p>hostname(主机名 ip)+(port)端口号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(location.host); console.log(location.hostname);</span><br></pre></td></tr></table></figure><h5 id="path"><a href="#path" class="headerlink" title="path"></a>path</h5><p>路径</p><h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><p>#锚点定位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(location.hash);</span><br></pre></td></tr></table></figure><h5 id="search"><a href="#search" class="headerlink" title="search"></a>search</h5><p>返回一个URL的查询部分</p><p>search:返回一个URL的查询部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(location.search);</span><br></pre></td></tr></table></figure><h5 id="Location-对象方法"><a href="#Location-对象方法" class="headerlink" title="Location 对象方法"></a>Location 对象方法</h5><h6 id="assign"><a href="#assign" class="headerlink" title="assign()"></a>assign()</h6><p>载入一个新的文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;assign&quot;).onclick=function()&#123;</span><br><span class="line">//跳转网页：在浏览器的历史记录中产生了一条新的浏览记录</span><br><span class="line">location.assign(&quot;http://www.baidu.com&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h6><p>用新的文档替换当前文档</p><p>replace() ：用新的文档替换当前文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;replace&quot;).onclick=function()&#123;</span><br><span class="line">//替换网页：不可回退</span><br><span class="line">location.replace(&quot;http://www.baidu.com&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="reload"><a href="#reload" class="headerlink" title="reload()"></a>reload()</h6><p>重新载入当前文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;reload&quot;).onclick=function()&#123;</span><br><span class="line">  location.reload()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><p>文档对象</p><h2 id="JS定时器"><a href="#JS定时器" class="headerlink" title="JS定时器"></a>JS定时器</h2><h3 id="周期性定时器"><a href="#周期性定时器" class="headerlink" title="周期性定时器"></a>周期性定时器</h3><p>setInterval()：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，<br>直到 clearInterval() 被调用或窗口被关闭。</p><p>周期性定时器（计时器）：每隔一段时间 执行一段代码<br>特点：一旦开启 就会永久执行，只能手动停止</p><p>setInterval(参数1,参数2)<br>参数1：回调函数 （就是执行代码）<br>参数2：时间间隔 （单位是ms）<br>setInterval有一个返回值 就是timeID（定时器ID）</p><h4 id="清除定时器"><a href="#清除定时器" class="headerlink" title="清除定时器"></a>清除定时器</h4><p>clearInterval(定时器ID)：清除定时器<br>定时器的ID: 在页面可以开启多个定时器 那么浏览器为了区分这些定时器，每当开启<br>一个定时器的时候，浏览器就会给这个定时器一个唯一的编号，那么这个编号就是定时器的ID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var timeID;</span><br><span class="line">   //点击开始计时</span><br><span class="line">   document.getElementById(&quot;start&quot;).onclick=function()&#123;</span><br><span class="line">   var num=0;</span><br><span class="line">   timeID=setInterval(function()&#123;</span><br><span class="line">      console.log(num++);</span><br><span class="line">   &#125;,1000);</span><br><span class="line">   &#125;</span><br><span class="line">   //清除定时器</span><br><span class="line">   document.getElementById(&quot;end&quot;).onclick=function()&#123;</span><br><span class="line">   clearInterval(timeID)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="一次性定时器"><a href="#一次性定时器" class="headerlink" title="一次性定时器"></a>一次性定时器</h3><p>setTimeout()：在指定的毫秒数后调用函数或计算表达式，一次性的，时间到就执行。</p><p>开启一次性定时器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var timeID=setTimeout(function()&#123;</span><br><span class="line">console.log(123);</span><br><span class="line">&#125;,3000)</span><br></pre></td></tr></table></figure><h4 id="清除定时器-1"><a href="#清除定时器-1" class="headerlink" title="清除定时器"></a>清除定时器</h4><p>clearTimeout():清除定时器,一般很少用</p><p>clearTimeout():清除定时器,一般很少用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearTimeout(timeID);</span><br></pre></td></tr></table></figure><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型介绍与使用"><a href="#原型介绍与使用" class="headerlink" title="原型介绍与使用"></a>原型介绍与使用</h3><p>每一个构造函数被创建,系统都会自动创建一个与构造函数相对应的对象,<br>那么这个对象就是原型。<br>访问原型对象的方法， 构造函数名.prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Student(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.sayHi=function()&#123;</span><br><span class="line">console.log(&quot;hello,我是&quot;+this.name+&quot;,我来自湖北&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var s1=new Student(&quot;小明&quot;,24);</span><br><span class="line">s1.sayHi();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.dir(Student);</span><br><span class="line"></span><br><span class="line">console.log(Student.prototype);</span><br></pre></td></tr></table></figure><p>构造函数的原型是一个对象 既然是对象 那么可以往里面添加属性和方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.type=&quot;children&quot;;</span><br><span class="line">Student.prototype.read=function()&#123;</span><br><span class="line">console.log(&quot;我是&quot;+this.name+&quot;,在读课文&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var s3=new Student(&quot;Tony&quot;,14);</span><br><span class="line">console.log(s3.type);</span><br><span class="line">s3.read();</span><br></pre></td></tr></table></figure><h3 id="往原型中添加的方法哪些可以访问"><a href="#往原型中添加的方法哪些可以访问" class="headerlink" title="往原型中添加的方法哪些可以访问"></a>往原型中添加的方法哪些可以访问</h3><p>构造函数自己可以访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Student.prototype.type);</span><br></pre></td></tr></table></figure><p>该构造函数实例化出来的对象可以访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s3=new Student(&quot;Tony&quot;,14);</span><br><span class="line">console.log(s3.type);</span><br><span class="line">s3.read();</span><br></pre></td></tr></table></figure><h3 id="什么样的数据可以放进原型"><a href="#什么样的数据可以放进原型" class="headerlink" title="什么样的数据可以放进原型"></a>什么样的数据可以放进原型</h3><p>该构造函数实例化出来的所有对象都共有的属性或者方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Student(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">//因为每一个实例化对象都有一个sayHi的方法 而且执行的函数体一样  所以可以写进原型里</span><br><span class="line">Student.prototype.sayHi=function()&#123;</span><br><span class="line">console.log(&quot;hello,我是&quot;+this.name+&quot;,我来自湖北&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.type=&quot;children&quot;;</span><br><span class="line">Student.prototype.read=function()&#123;</span><br><span class="line">console.log(&quot;我是&quot;+this.name+&quot;,在读课文&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>    //共有的属性或者方法 指的是所有的实例化对象都有这个属性 并且属性都一样    Student.prototype.gender=&quot;女&quot;        var s1=new Student(&quot;二狗&quot;,15);    console.log(s1.gender)//女</code></pre><h3 id="构造函数访问对象的规则"><a href="#构造函数访问对象的规则" class="headerlink" title="构造函数访问对象的规则"></a>构造函数访问对象的规则</h3><p>原型 ：构造函数名.prototype<br>最先访问实例化对象自己的 如果没有 就访问构造函数里面的 如果还没有就访问原型里面的（就近原则）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Dog(name,breed)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.breed=breed;</span><br><span class="line">//构造函数内部的方法</span><br><span class="line">this.sayHi=function()&#123;</span><br><span class="line">console.log(&quot;我是构造函数里面的sayHi方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//构造函数原型里面的</span><br><span class="line">Dog.prototype.sayHi=function()&#123;</span><br><span class="line">console.log(&quot;汪汪汪,我是&quot;+this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>var d1=new Dog(&quot;小白&quot;,&quot;博美&quot;);d1.sayHi();//实例化对象自己的 单个对象独有的方法d1.sayHi=function()&#123;    console.log(&quot;我是d1里面的sayHi方法&quot;);&#125;    d1.sayHi();</code></pre><h3 id="修改原型中的方法"><a href="#修改原型中的方法" class="headerlink" title="修改原型中的方法"></a>修改原型中的方法</h3><p>访问原型 必须要使用 构造函数名.prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">//给每只猫一个猫叫方法</span><br><span class="line">Cat.prototype.miao=function()&#123;</span><br><span class="line">console.log(&quot;喵喵喵,我叫&quot;+this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype.miao=function()&#123;</span><br><span class="line">console.log(&quot;我是真正的原型修改后的方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    // var c1=new Cat(&quot;隔壁小黄&quot;,2);    // c1.miao();    // //只是给c1这个对象添加一个miao方法 并没有修改原型    // c1.miao=function()&#123;    // console.log(&quot;我是修改原型后的方法&quot;)// 结果没有被修改    // &#125;    // c1.miao();        console.log(Cat.prototype);        //另外再创建一个对象来访问原型    var c2=new Cat(&quot;小花&quot;,3)    c2.miao();//如果打印&quot;我是修改原型后的方法&quot; 说明原型修改成功了 如果还是原来的 那么说明没有修改</code></pre><h3 id="原型替换"><a href="#原型替换" class="headerlink" title="原型替换"></a>原型替换</h3><p>原型可以使用另外一个对象来替换,那么我们实例化对象过后 调用原型中的方法 是替换前的还是替换后的取决与我们实例化对象操作是在原型替换前还是在原型替换后</p><pre><code>function Person(name,age)&#123;    this.name=name;    this.age=age;&#125;//给原型添加一个方法Person.prototype.sayHi=function()&#123;    console.log(&quot;大家好,我是&quot;+this.name);&#125;// var p1=new Person(&quot;Lucy&quot;,18);// p1.sayHi();//替换原型Person.prototype=&#123;    sayHi:function()&#123;        console.log(&quot;我是原型替换后的sayHi方法&quot;);    &#125;&#125;var p1=new Person(&quot;Lucy&quot;,18);p1.sayHi();</code></pre><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>创建的每一个对象 都有一个原型 那么这个原型也是一个对象 所以原型也有原型 那么这种情况下就会形成一个链式结构 就是原型链<br>js内置对象的原型链(Date Array Math)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Students(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Students.prototype.read=function()&#123;</span><br><span class="line">console.log(&quot;大家好，我叫&quot;+this.name+&quot;，我在阅读课文&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>    var s1=new Students(&quot;Jack&quot;,19);    s1.read();        // s1.study(); //报错    // console.log(s1.gender);//undefined        //s1.sing(); //报错        s1.toString(); </code></pre><p>对象自己里面没有定义toString方法 构造函数的原型里面也没有，那么这个方法为什么没有报错<br>对象 访问某个成员 先在自己里面找 如果没有就去构造函数里面找 构造函数如果没有<br>就去原型里面找 原型里面没有 就沿着原型链往上找 找到最后 如果找到null 还没找到<br>那么就会报错 或者undefined</p><pre><code>    console.log(Students.prototype===s1.__proto__); //true        console.log(Students.prototype.__proto__);    console.log(s1.__proto__);    console.log(s1.__proto__.__proto__);    console.log(s1.__proto__.__proto__.constructor); //Object对象        console.log(s1.__proto__.__proto__===Object.prototype);//true    console.log(s1.__proto__.__proto__.__proto__);//null</code></pre><h4 id="proto"><a href="#proto" class="headerlink" title="_ _ proto_ _"></a>_ _ proto_ _</h4><p>_ _ proto_ _ 是属于构造函数实例化对象的一个属性这个属性指向实例化这个对象的构造函数的原型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi=function()&#123;</span><br><span class="line">console.log(&quot;大家好,我是&quot;+this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p1=new Person(&quot;Smith&quot;,25)</span><br><span class="line">console.log(p1);</span><br></pre></td></tr></table></figure><pre><code>    console.log(Person.prototype);    console.log(p1.__proto__===Person.prototype); //true</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype=&#123;</span><br><span class="line">sayHi:function()&#123;</span><br><span class="line">console.log(222);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    //可以这样来操作构造函数的原型 但是不推荐使用    //而且__proto__不是W3C的标准语法 所以开发时不要用         p1.__proto__=&#123;        sayHi:function()&#123;            console.log(222);        &#125;    &#125;</code></pre><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>constructor 是属于构造函数原型里面的一个属性,指向构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi=function()&#123;</span><br><span class="line">console.log(&quot;大家好,我是&quot;+this.name);</span><br><span class="line">&#125;</span><br><span class="line">console.log(Person.prototype);</span><br><span class="line">console.log(Person.prototype.constructor);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.prototype.constructor===Person);//true</span><br><span class="line">var p1=new Person.prototype.constructor(&quot;Amy&quot;,18);//这么写没有问题不会报错 但一般不会这么写</span><br><span class="line">console.log(p1);</span><br></pre></td></tr></table></figure><pre><code>    //替换原型之后 会有丢失constructor属性的现象 所以要找回        // Person.prototype=&#123;    // type:&quot;人类&quot;    // &#125;    // console.log(Person.prototype.constructor===Person);//false        Person.prototype=&#123;        type:&quot;人类&quot;,        constructor:Person    &#125;    //手动给了constructor属性之后 就又指向原来的构造函数了    console.log(Person.prototype.constructor===Person);//true</code></pre><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof 就是用来判断这个构造函数的prototype属性在不在这个对象的原型链上<br>instanceof 是一种运算符 判断一个对象上是否存在prototype属性<br>语法: 对象 instanceof 构造函数<br>返回值: true&#x2F;false</p><pre><code>    var arr=new Array(12,20,30);    console.log(typeof arr); //object        var obj=&#123;        name:&quot;lucy&quot;    &#125;;    console.log(typeof obj);//object    console.log(arr instanceof Array); //true    console.log(arr instanceof Object); //true</code></pre><p>Function作为对象的时候的原型链：<br>Function—Function.prototype—Object.prototype—null</p><pre><code>console.log(Function instanceof Function); //trueconsole.log(Function instanceof Object); //true</code></pre><p>所有的原型链最后都走到了Object.prototype<br>说明所有的对象(包括数组对象 普通对象 内置对象 以及函数) 都可以访问Object.prototype里面的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype);</span><br></pre></td></tr></table></figure><h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h4><p>hasOwnProperty 是一个方法<br>参数 是一个字符串 属性名<br>返回值 boolean类型的数据<br>作用：用来判断这个属性是不是属于对象自己的(判断不包括构造函数原型里面的成员)</p><p>hasOwnProperty<br>hasOwnProperty 是一个方法<br>参数 是一个字符串 属性名<br>返回值 boolean类型的数据<br>作用：用来判断这个属性是不是属于对象自己的(判断不包括构造函数原型里面的成员)</p><pre><code>    function Student(name,age)&#123;        this.name=name;        this.age=age;    &#125;        Student.prototype.type=&quot;人类&quot;;        var s1=new Student(&quot;张三&quot;,18);    console.log(s1.hasOwnProperty(&quot;name&quot;));//true    console.log(s1.hasOwnProperty(&quot;age&quot;));//true    console.log(s1.hasOwnProperty(&quot;type&quot;));//false</code></pre><h4 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf"></a>isPrototypeOf</h4><p>isPrototypeOf<br>参数：是一个对象 相当于是作为原型出现的<br>返回值 boolean类型的数据<br>作用：判断一个对象是不是另一个对象的原型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1=&#123;</span><br><span class="line">   name:&quot;张三&quot;,</span><br><span class="line">   age:12</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var obj=&#123;</span><br><span class="line">   name:&quot;李四&quot;,</span><br><span class="line">   age:30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>   //替换原型   obj.__proto__=obj1      console.log(obj1.isPrototypeOf(obj)) //true</code></pre><p>给对象添加方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">//创建一个自己的数组的构造函数</span><br><span class="line">function MyArray()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(MyArray.prototype);</span><br><span class="line">//替换原型 让他可以有数组的一些方法</span><br><span class="line">MyArray.prototype=[];</span><br><span class="line"></span><br><span class="line">MyArray.prototype.sayHi=function()&#123;</span><br><span class="line">console.log(55555);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr1=new MyArray();</span><br><span class="line">arr1.push();</span><br><span class="line"></span><br><span class="line">arr1.sayHi();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><h4 id="内置对象的原型链"><a href="#内置对象的原型链" class="headerlink" title="内置对象的原型链"></a>内置对象的原型链</h4><h5 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h5><pre><code>    var arr1=new Array(10,20,30);    console.log(arr1);    console.log(arr1.__proto__);    console.log(arr1.__proto__===Array.prototype);//true</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr1.__proto__.__proto__);</span><br><span class="line">console.log(arr1.__proto__.__proto__.constructor);</span><br><span class="line">console.log(arr1.__proto__.__proto__===Object.prototype);//true</span><br></pre></td></tr></table></figure><h5 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h5><pre><code>var d1=new Date();console.dir(d1);console.log(d1.__proto__);console.log(d1.__proto__===Date.prototype);//trueconsole.log(d1.__proto__.__proto__);console.log(d1.__proto__.__proto__===Object.prototype);//trueconsole.log(d1.__proto__.__proto__.__proto__);//null</code></pre><h5 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h5><pre><code>var obj=new Object();console.log(obj);var div=document.getElementById(&quot;box&quot;);var p=document.getElementById(&quot;p&quot;);</code></pre><h4 id="函数的原型链"><a href="#函数的原型链" class="headerlink" title="函数的原型链"></a>函数的原型链</h4><p>test 作为对象 它是有原型的 也有对应的构造函数 是Function</p><pre><code>    function test()&#123;        console.log(1111);    &#125;        //验证test是一个对象    test.study=function()&#123;        console.log(222);    &#125;    test.lesson=&quot;语文&quot;;        //说明函数也是一个对象    test.study();    console.log(test.lesson);        console.dir(test);        //寻找test的原型链    console.log(test.__proto__); // xxx.prototype    console.log(test.__proto__.constructor);//Function()    console.log(test.__proto__===Function.prototype);//true    //test._proto_===xxx.prototype        var t1=new test();    console.log(t1);        console.log(t1.__proto__);    console.log(t1.__proto__===test.prototype);//true        function Student(name,age)&#123;        this.name=name;        this.age=age;    &#125;    var s1=new Student(&quot;张三&quot;,24)</code></pre><h3 id="函数对象中的属性"><a href="#函数对象中的属性" class="headerlink" title="函数对象中的属性"></a>函数对象中的属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">console.log(111);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    console.log(test);</code></pre><h4 id="1-caller-调用者"><a href="#1-caller-调用者" class="headerlink" title="1.caller 调用者"></a>1.caller 调用者</h4><p>如果函数2 在函数1中 那么函数2的caller就是函数1<br>如果一个函数没有在任何函数里面调用 那么它的caller就为null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test1()&#123;</span><br><span class="line">console.log(222);</span><br><span class="line">// console.log(test1.caller); //null</span><br><span class="line">test2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test2()&#123;</span><br><span class="line">console.log(333);</span><br><span class="line">console.log(test2.caller)//打印出了test1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>    test1();</code></pre><h4 id="2-length-长度"><a href="#2-length-长度" class="headerlink" title="2.length 长度"></a>2.length 长度</h4><p>表示的是函数形参的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test3(n1,n2,n3)&#123;</span><br><span class="line">console.log(444);</span><br><span class="line">console.log(test3.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test3(12);</span><br></pre></td></tr></table></figure><h4 id="3-name-表示函数名"><a href="#3-name-表示函数名" class="headerlink" title="3.name 表示函数名"></a>3.name 表示函数名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test4()&#123;</span><br><span class="line">console.log(test4.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test4();</span><br></pre></td></tr></table></figure><h4 id="4-arguments"><a href="#4-arguments" class="headerlink" title="4.arguments"></a>4.arguments</h4><p>函数.arguments 也是一个伪数组 记录形参<br>作用：获取函数所有的实参<br>特点：<br>1、arguments只能在函数里面使用，在函数外使用会报错<br>2、arguments是一个伪数组，有数组三要素 但不可以调用数组方法<br>3、修改了形参，arguments也会随之改变<br>4、修改了arguments的值，形参也会发生变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test5(n1,n2,n3)&#123;</span><br><span class="line">n1=100;</span><br><span class="line">console.log(arguments);//保存的是实参的值</span><br><span class="line">console.log(test5.arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test5(12,20,30);</span><br></pre></td></tr></table></figure><h5 id="4-1-arguments-callee-被调用者"><a href="#4-1-arguments-callee-被调用者" class="headerlink" title="4.1. arguments.callee 被调用者"></a>4.1. arguments.callee 被调用者</h5><p>用的多 是匿名函数自调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var num=0;</span><br><span class="line">(function()&#123;</span><br><span class="line">console.log(111);</span><br><span class="line">num++;</span><br><span class="line">if(num&gt;=10)&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">arguments.callee();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h5 id="4-2-arguments-length-实参的长度"><a href="#4-2-arguments-length-实参的长度" class="headerlink" title="4.2.arguments.length 实参的长度"></a>4.2.arguments.length 实参的长度</h5><p>4.2.arguments.length 实参的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr=[10,20,50];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">Array.prototype.push=function()&#123;</span><br><span class="line"> console.log(111112222);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>   arr.push();   console.log(arr);</code></pre><h3 id="实例成员和静态成员"><a href="#实例成员和静态成员" class="headerlink" title="实例成员和静态成员"></a>实例成员和静态成员</h3><p>实例成员：就是由实例化对象点出来的成员（属性或方法）<br>静态成员：就是由构造函数点出来的成员（属性或方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">//直接向构造函数添加属性和方法</span><br><span class="line">//静态成员：就是由构造函数点出来的成员（属性或方法）</span><br><span class="line">Person.sayHi=function()&#123;</span><br><span class="line">console.log(&quot;哈哈哈&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.sayHi();</span><br><span class="line">//向构造函数的原型里面添加属性和方法</span><br><span class="line">// 实例成员：就是由实例化对象点出来的成员（属性或方法）</span><br><span class="line">Person.prototype.sayHi=function()&#123;</span><br><span class="line">console.log(&quot;嘻嘻嘻&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    //向实例化对象里面添加属性或方法    var p1=new Person(&quot;张三&quot;,25);    p1.sayHi=function()&#123;        console.log(&quot;呵呵呵&quot;);    &#125;        p1.sayHi();        // var p2=new Person(&quot;lisi&quot;,23);    // p2.sayHi(); //报错 获取不到</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的介绍"><a href="#继承的介绍" class="headerlink" title="继承的介绍"></a>继承的介绍</h3><p>JS 是一种面向对象的 弱类型的 解释性的语言<br>弱类型 声明变量的时候不需要注明数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a =1;    </span><br><span class="line">float//（强类型）  </span><br><span class="line">var a=1.2;</span><br></pre></td></tr></table></figure><p>解释性 解释一句执行一句 编译性 一次性全部翻译完 然后再执行</p><p>面向对象 封装 继承 多态 （js语言没有多态）<br>封装 将一个功能都放在一个对象里面 只需要向外界暴露一个接口 需要使用的时候 直接调接口就可以了并不需要管底层是怎么实现的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push //向数组的最后添加一个元素</span><br><span class="line">var arr=[12,23]; </span><br><span class="line">arr.push(15);</span><br></pre></td></tr></table></figure><p>继承：是指js对象之间的继承 如果我们想让一个对象拥有另一个对象的属性或者方法 那么就可以让这个对象继承另一个对象</p><h3 id="实现继承的方式"><a href="#实现继承的方式" class="headerlink" title="实现继承的方式"></a>实现继承的方式</h3><p>1.实现构造函数来实现继承<br>实现方式：使用call等方法 是一个对象的this指向另一个对象 从而让其拥有这个对象的属性和方法<br>缺点：无法继承父类原型上面的方法 对于子类不需要的方法 每次创建都会拥有 浪费内存空间<br>有很多构造函数的情况下，如果需要给所有的构造函数添加属性 ，那么就需要分别去加 就不便于维护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Perent(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">this.work=function()&#123;</span><br><span class="line">console.log(&quot;我要赚钱&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Perent.prototype.test=function()&#123;</span><br><span class="line">console.log(111);</span><br><span class="line">&#125;</span><br><span class="line">Perent.prototype.type=&quot;人类&quot;;</span><br><span class="line"></span><br><span class="line">var p1=new Perent(&quot;父亲&quot;,36);</span><br><span class="line"></span><br><span class="line">// function Child(name,age,gender)&#123;</span><br><span class="line">// this.name=name;</span><br><span class="line">// this.age=age;</span><br><span class="line">// &#125;</span><br><span class="line">// var c1=new Child(&quot;孩子&quot;,12);</span><br><span class="line"></span><br><span class="line">// call apply bind 修改this指向</span><br><span class="line"></span><br><span class="line">function Child(name,age)&#123;</span><br><span class="line">Perent.call(this,name,age)</span><br><span class="line">&#125;</span><br><span class="line">var c2=new Child(&quot;amy&quot;,12);</span><br><span class="line">console.log(c2);</span><br><span class="line"></span><br><span class="line">//c2.test();  //报错</span><br><span class="line">c2.work() //执行了函数体</span><br></pre></td></tr></table></figure><p>就是说只是把父亲构造函数里面的属性和方法继承了 但是父类原型里面的方法继承不了<br>创建的child对象并不需要work方法 但每次创建都会有 浪费空间</p><p>2.原型拷贝继承(混入式继承)<br>实现方式：使用for-in遍历父类原型里面的所有属性 依次加入子类的原型中<br>缺点：原型中子类不需要的方法或者属性也继承过来了 占用内存空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function Perent(name,age)&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">  this.work=function()&#123;</span><br><span class="line">  console.log(&quot;我要赚钱&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Perent.prototype.test=function()&#123;</span><br><span class="line">  console.log(111);</span><br><span class="line">  &#125;</span><br><span class="line">  Perent.prototype.type=&quot;人类&quot;;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  function Child(name,age)&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //原型对象拷贝</span><br><span class="line">  for(var key in Perent.prototype)&#123;</span><br><span class="line">  Child.prototype[key]=Perent.prototype[key];</span><br><span class="line">  console.log(Perent.prototype[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  var c1=new Child(&quot;张三&quot;,12);</span><br><span class="line">  c1.test();</span><br><span class="line">  console.log(c1.type);</span><br></pre></td></tr></table></figure><p>3.原型链继承<br>实现方法：利用原型链来实现继承 父类的一个实例化对象作为子类的原型<br>缺点：子类实例和父类实例的原型对象上有成员的共享问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Perent(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">this.work=function()&#123;</span><br><span class="line">console.log(&quot;我要赚钱&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Perent.prototype.test=function()&#123;</span><br><span class="line">console.log(111);</span><br><span class="line">&#125;</span><br><span class="line">Perent.prototype.type=&quot;人类&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Child(name,age)&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Child.prototype=new Perent();</span><br><span class="line"></span><br><span class="line">console.log(Child.prototype.constructor);</span><br><span class="line">//重新替换原型之后 构造函数并不指向原构造函数 所以要将构造函数指向原函数</span><br><span class="line">Child.prototype.constructor=Child;</span><br><span class="line"></span><br><span class="line">Child.prototype=new Perent();</span><br><span class="line"></span><br><span class="line">var c1=new Child(&quot;张三&quot;,12);</span><br><span class="line">console.log(c1.type);</span><br><span class="line">c1.test();</span><br></pre></td></tr></table></figure><p>为什么不直接使用Child.prototype&#x3D;Perent？<br>把父类的构造函数直接替换掉子类的原型会导致 父类构造函数的私有属性发生变化<br>甚至有些成员 父类构造函数并不需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype=Perent; </span><br><span class="line">Child.prototype.study=function()&#123; </span><br><span class="line">console.log(&quot;good good study&quot;); </span><br><span class="line">&#125; </span><br><span class="line">console.dir(Perent); </span><br><span class="line">Perent.study();</span><br></pre></td></tr></table></figure><p>4.组合继承（原型链 和call继承组合）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function Father()&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.run=function()&#123;</span><br><span class="line">console.log(this.name+&quot;我要跑步&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype=&#123;</span><br><span class="line">constructor:Father,</span><br><span class="line">type:&quot;人类&quot;,</span><br><span class="line">eat:function()&#123;</span><br><span class="line">console.log(this.name+&quot;我要吃饭&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son(age)&#123;</span><br><span class="line">//这个是继承父类构造函数里面的属性或者方法</span><br><span class="line">Father.call(this);</span><br><span class="line">this.age=age;</span><br><span class="line">this.study=function()&#123;</span><br><span class="line">console.log(this.name+&quot;我要开始学习了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//继承父类原型中的成员</span><br><span class="line">Son.prototype=new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype.constructor=Son;</span><br><span class="line"></span><br><span class="line">Son.prototype.sleep=function()&#123;</span><br><span class="line">console.log(this.name+&quot;我要睡觉了&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s1=new Son(12);</span><br><span class="line">//这个是父类构造函数里面的方法</span><br><span class="line">s1.run();</span><br><span class="line"></span><br><span class="line">//是父类原型里面的方法</span><br><span class="line">s1.eat();</span><br><span class="line">console.log(s1.type);</span><br><span class="line"></span><br><span class="line">//自己构造函数里面的方法</span><br><span class="line">s1.study();</span><br><span class="line"></span><br><span class="line">//自己的原型里面的方法</span><br><span class="line">s1.sleep();</span><br></pre></td></tr></table></figure><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。<br>所有浏览器都支持event对象，但支持的方式不同。<br>比如鼠标操作时候，会添加鼠标位置的相关信息到事件对象中。（类似Date）<br>普通浏览器支持 event（带参，任意参数）<br>IE 678 支持 window.event（无参，内置）<br>总结：他是一个事件中的内置对象。内部装了很多关于鼠标和事件本身的信息。</p><p>谷歌火狐 一般是给事件处理函数添加一个形参 event ev e<br>IE8 使用一个全局变量来保存和事件相关的信息</p><h4 id="事件对象的三大坐标系"><a href="#事件对象的三大坐标系" class="headerlink" title="事件对象的三大坐标系"></a>事件对象的三大坐标系</h4><p><strong>screenX</strong>、<strong>screenY</strong> 表示的是从鼠标点击的点到屏幕左上角的距离<br><strong>clientX</strong>、<strong>clientY</strong>表示的是从鼠标点击的点到可视区域左上角距离<br><strong>pageX</strong>、<strong>pageY</strong> 表示的是从鼠标点击的点到页面左上角的距离（和页面无关）<br>用的最多 就是元素定位坐标</p><h5 id="兼容性封装"><a href="#兼容性封装" class="headerlink" title="兼容性封装"></a>兼容性封装</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function getPagePount(e)&#123;</span><br><span class="line">var x=e.pageX||getPageScroll().scrollLeft+e.clientX||0;</span><br><span class="line">var y=e.pageY||getPageScroll().scrollTop+e.clientY||0;</span><br><span class="line"></span><br><span class="line">return&#123;</span><br><span class="line">pageX:x,</span><br><span class="line">pageY:y</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getPageScroll()&#123;</span><br><span class="line">//逻辑或的短路运算规则：找真</span><br><span class="line">//如果这几种情况都不满足，那么就返回undefined  但是有的浏览器不支持undefined</span><br><span class="line">var left=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;</span><br><span class="line">var top=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;</span><br><span class="line">//函数返回值</span><br><span class="line">return &#123;</span><br><span class="line">scrollLeft:left,</span><br><span class="line">scrollTop:top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Event对象"><a href="#Event对象" class="headerlink" title="Event对象"></a>Event对象</h3><p>Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的<br>位置、鼠标按钮的状态。用来获取事件的详细信息<br>事件通常与函数结合使用，函数不会在事件发生前被执行！</p><p>事件对象 event 的获取<br>IE678中，window.event<br>在火狐谷歌中，event或者，在事件绑定的函数中，加参，这个参数就是event.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box.onclick = function (e)&#123; e就是event &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var box=document.getElementById(&quot;box&quot;); box.onclick=function(e)&#123; </span><br><span class="line">e=e||window.event </span><br><span class="line">console.log(e);  </span><br><span class="line">console.log(111); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三个家族"><a href="#三个家族" class="headerlink" title="三个家族"></a>三个家族</h3><h4 id="offset家族介绍"><a href="#offset家族介绍" class="headerlink" title="offset家族介绍"></a>offset家族介绍</h4><p>offset这个单词本身是–偏移，补偿，位移的意思。<br>js中有一套方便的获取元素尺寸的办法就是offset家族；<br>offsetWidth、offsetHight 、offsetLeft、offsetTop以及offsetParent<br>共同组成了offset家族。</p><p>offset属性家族：offsetWidth offsetHeight offsetLeft offsetTop<br>offset属性家族(offsetWidth offsetHeight)获取元素的宽高的特点：<br>1.可以获取行内属性 也可以获取行外属性<br>2.获取的属性值是nummber类型 而且不带单位<br>3.获取到的是页面显示的元素的真实宽高(width&#x2F;height + padding + border)</p><h5 id="offsetWidth和offsetHight"><a href="#offsetWidth和offsetHight" class="headerlink" title="offsetWidth和offsetHight"></a>offsetWidth和offsetHight</h5><p> （检测盒子自身宽高+padding+border）</p><p>这两个属性，他们绑定在了所有的节点元素上。获取之后，只要调用这两个属性，我们就能够获取元素节点的宽和高。<br>offset宽&#x2F;高 &#x3D; 盒子自身的宽&#x2F;高 + padding +border；<br>offsetWidth &#x3D; width+padding+border；<br>offsetHeight &#x3D; Height+padding+border；</p><h5 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h5><p>（检测父系盒子中带有定位的父盒子节点）<br>offsetParent:获取元素最近的父级定位元素，返回该对象的父级 （带有定位）<br>1.如果元素自身是固定定位，那么获取到的父级为null<br>2.如果元素自身不是固定定位(absolute relative) 那么就往上找父级定位，如果所有的父级元素<br>都没有定位，那么找到的定位父级就是body。<br>3.body的定位父级为null</p><p>因为偏移量家族的Element的属性，所以每一个元素都具有offsetParent这个属性，它用来获取自己的祖先元素中，并且是已经定位的祖先元素，还有优先获取距离自己最近的元素，如果没有定位的祖先元素了，就是以body为其参考，获取body的标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">#box&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: #0f0;</span><br><span class="line">/* position:absolute; */</span><br><span class="line">&#125;</span><br><span class="line">.two&#123;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 200px;</span><br><span class="line">background-color: pink;</span><br><span class="line">/* position: relative; */</span><br><span class="line">&#125;</span><br><span class="line">.three&#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-color: skyblue;</span><br><span class="line">/* position:absolute; */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;three&quot;&gt;</span><br><span class="line">&lt;div class=&quot;two&quot;&gt;</span><br><span class="line">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   var box=document.getElementById(&quot;box&quot;);</span><br><span class="line">   console.log(box.offsetParent);</span><br><span class="line">   console.log(document.body.offsetParent); //null</span><br><span class="line">   </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="offsetLeft和offsetTop"><a href="#offsetLeft和offsetTop" class="headerlink" title="offsetLeft和offsetTop"></a>offsetLeft和offsetTop</h5><p>（检测距离父盒子有定位的左&#x2F;上面的距离）<br>offsetTop offsetLeft:获取元素在页面上的真实位置<br>offsetTop:获取到的是元素上外边框到定位父级(offsetParent)上内边框的距离<br>offsetLeft:获取到的是元素左外边框到定位父级(offsetParent)左内边框的距离</p><h6 id="offsetLeft和style-left区别"><a href="#offsetLeft和style-left区别" class="headerlink" title="offsetLeft和style.left区别"></a>offsetLeft和style.left区别</h6><p>1、最大区别在于offsetLeft可以返回没有定位盒子的距离左侧的位置。而 style.left不可以<br>2、offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。<br>3、offsetTop 只读，而 style.top 可读写。（只读是获取值，可写是赋值）<br>4、如果没有给 HTML 元素指定过 top 样式，则style.top 返回的是空字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.one&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: skyblue;</span><br><span class="line">border: 10px pink solid;</span><br><span class="line">margin: 20px;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 50px;</span><br><span class="line">left: 50px;</span><br><span class="line">&#125;</span><br><span class="line">.two&#123;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 200px;</span><br><span class="line">background-color: #00FF00;</span><br><span class="line">border: 10px solid purple;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;two&quot;&gt;</span><br><span class="line">&lt;div id=&quot;box&quot; class=&quot;one&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   var box=document.getElementById(&quot;box&quot;);</span><br><span class="line">    </span><br><span class="line">console.log(box.offsetTop);</span><br><span class="line">console.log(box.offsetLeft);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Scroll家族"><a href="#Scroll家族" class="headerlink" title="Scroll家族"></a>Scroll家族</h4><p>scroll家族:scrollWidth scrollHeight scrollLeft scrollTop</p><h5 id="scrollWidth、scrollHeight"><a href="#scrollWidth、scrollHeight" class="headerlink" title="scrollWidth、scrollHeight"></a>scrollWidth、scrollHeight</h5><p>（不包括border）<br>scrollWidth：返回元素的整体宽度，包括由于溢出而无法展示在网页的不可见部分。<br>scrollHeight ：返回元素的整体高度，包括由于溢出而无法展示在网页的不可见部分。<br>作用：获取元素内容真实的宽高 仅限于IE8</p><h5 id="scrollLeft、scrollTop"><a href="#scrollLeft、scrollTop" class="headerlink" title="scrollLeft、scrollTop"></a>scrollLeft、scrollTop</h5><p>scrollLeft、 scrollTop是获取元素内容真实得到的位置,<br>scrollLeft ：返回元素左边缘与视图之间的距离，（返回或设置匹配元素的滚动条的水平位置。）<br>这里的视图指的是元素的内容（包括子元素以及内容）。<br>scrollTop ：返回元素上边缘与视图之间的距离。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">#box&#123;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 200px;</span><br><span class="line">border: 1px solid pink;</span><br><span class="line"></span><br><span class="line">overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">vertical-align: top;</span><br><span class="line">/* width: 300px;</span><br><span class="line">height: 300px; */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./img/5dd3a066a1691.jpg&quot; &gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var box=document.getElementById(&quot;box&quot;);</span><br><span class="line"></span><br><span class="line">//offset家族:获取元素真实的宽高和位置</span><br><span class="line">console.log(box.offsetWidth);//202</span><br><span class="line">console.log(box.offsetHeight);//202</span><br><span class="line"></span><br><span class="line">//scroll家族:scrollWidth scrollHeight scrollLeft scrollTop</span><br><span class="line">console.log(box.scrollWidth);//1920 </span><br><span class="line">console.log(box.scrollHeight);//1200</span><br><span class="line"></span><br><span class="line">console.log(box.scrollLeft);//0</span><br><span class="line">console.log(box.scrollTop);//0</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="scroll家族兼容性问题"><a href="#scroll家族兼容性问题" class="headerlink" title="scroll家族兼容性问题"></a>scroll家族兼容性问题</h5><p>获得scrollTop 或者 scrollLeft的值有三种方式</p><p>1.支持谷歌浏览器和没有声明<code>&lt;!DOCTYPE html&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.body.scrollTop </span><br><span class="line">document.body.scrollLeft</span><br></pre></td></tr></table></figure><p>2.支持火狐和其它浏览器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement.scrollTop </span><br><span class="line">document.documentElement.scrollLeft</span><br></pre></td></tr></table></figure><p>3.支持ie9+ 和 最新浏览器 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.pageXOffset </span><br><span class="line">window.pageYOffset</span><br></pre></td></tr></table></figure><p><strong>兼容性封装：</strong></p><p>方法一：（scrollLeft兼容封装，scrollTop同理）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getPageScroll()&#123;</span><br><span class="line"> //能力检测</span><br><span class="line"> if(window.pageXOffset)&#123; //说明是谷歌火狐</span><br><span class="line">return window.pageXOffset;</span><br><span class="line"> &#125;else if(document.documentElement.scrollLeft)&#123; //IE8</span><br><span class="line"> return document.documentElement.scrollLeft;</span><br><span class="line"> &#125;else&#123;</span><br><span class="line"> return document.body.scrollLeft;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getPageScroll()&#123;</span><br><span class="line">//逻辑或的短路运算规则：找真</span><br><span class="line">//如果这几种情况都不满足，那么就返回undefined  但是有的浏览器不支持undefined</span><br><span class="line">var left=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;</span><br><span class="line">var top=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;</span><br><span class="line">//函数返回值</span><br><span class="line">return &#123;</span><br><span class="line">scrollLeft:left,</span><br><span class="line">scrollTop:top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getPageScroll().scrollLeft,getPageScroll().scrollTop);</span><br></pre></td></tr></table></figure><h4 id="client家族"><a href="#client家族" class="headerlink" title="client家族"></a>client家族</h4><p>client家族的作用：获取页面的可视区域</p><p>clientWidth 获取网页可视区域宽度（两种用法）<br>clientHeight 获取网页可视区域高度（两种用法）</p><p>调用者不同，意义不同：<br>盒子调用： 指盒子本身。<br>body&#x2F;html调用：可视区域大小。</p><p>clientX：鼠标距离可视区域左侧距离（event调用）<br>clientY：鼠标距离可视区域上侧距离（event调用）</p><p>clientTop&#x2F;clientLeft：盒子的border宽高也就是实际获取到的是左边框和上边框，用的少</p><h5 id="client家族兼容性问题"><a href="#client家族兼容性问题" class="headerlink" title="client家族兼容性问题"></a>client家族兼容性问题</h5><p>谷歌火狐支持的获取页面可视区域的属性：window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.innerWidth </span><br><span class="line">window.innerHeight</span><br></pre></td></tr></table></figure><p>IE8 及其以下：document.documentElement（html）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement.clientWidth </span><br><span class="line">document.documentElement.clientHeight</span><br></pre></td></tr></table></figure><p>其他浏览器：body</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.body.clientWidth </span><br><span class="line">document.body.clientHeight</span><br></pre></td></tr></table></figure><p><strong>兼容性封装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getClientSize()&#123;</span><br><span class="line">   var width=document.documentElement.clientWidth||window.innerWidth||document.body.clientWidth||0;</span><br><span class="line">   var height=document.documentElement.clientHeight||window.innerHeight||document.body.clientHeight||0;</span><br><span class="line"></span><br><span class="line">return&#123;</span><br><span class="line">clientWidth:width,</span><br><span class="line">clientHeight:height</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>一个页面适应多个终端<br>屏幕宽度 1000以上是pc端<br>屏幕宽度 1000—600是平板<br>屏幕宽度 600以下是手机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.onresize=function()&#123;</span><br><span class="line">   //获取屏幕宽高</span><br><span class="line">   var width=getClientSize().clientWidth;</span><br><span class="line">   </span><br><span class="line">   //进行判断</span><br><span class="line">   if(width&gt;1000)&#123; //pc端 </span><br><span class="line">   document.body.style.backgroundColor=&quot;pink&quot;;</span><br><span class="line">   &#125;else if(width&gt;=600)&#123; //平板</span><br><span class="line">   document.body.style.backgroundColor=&quot;yellow&quot;;</span><br><span class="line">   &#125;else&#123; //手机</span><br><span class="line">   document.body.style.backgroundColor=&quot;green&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="获取页面可视区域的大小的兼容性"><a href="#获取页面可视区域的大小的兼容性" class="headerlink" title="获取页面可视区域的大小的兼容性"></a>获取页面可视区域的大小的兼容性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getClientSize()&#123;</span><br><span class="line">      var width=document.documentElement.clientWidth||window.innerWidth||document.body.clientWidth||0;</span><br><span class="line">      var height=document.documentElement.clientHeight||window.innerHeight||document.body.clientHeight||0;</span><br><span class="line">   </span><br><span class="line">   return&#123;</span><br><span class="line">   clientWidth:width,</span><br><span class="line">   clientHeight:height</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="匀速动画的封装"><a href="#匀速动画的封装" class="headerlink" title="匀速动画的封装"></a>匀速动画的封装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//封装：</span><br><span class="line">function Animation(ele,target)&#123;</span><br><span class="line">//开启一个定时器之前，先清除原本存在的定时器</span><br><span class="line">clearInterval(ele.timeID);</span><br><span class="line">ele.timeID=setInterval(function()&#123;</span><br><span class="line">//获取当前位置</span><br><span class="line">var currentLeft=ele.offsetLeft;</span><br><span class="line">//方向判断</span><br><span class="line">if(currentLeft&lt;target)&#123;</span><br><span class="line">var isLeft=true;//从左往右</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var isLeft=false;//从右往左</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// var isLeft;</span><br><span class="line">// currentLeft&lt;target?isLeft=true:isLeft=false;</span><br><span class="line"></span><br><span class="line">// var isLeft = currentLeft &lt; target ? true : false ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//判断移动盒子是加还是减</span><br><span class="line">if(isLeft)&#123;</span><br><span class="line">//移动盒子</span><br><span class="line">currentLeft+=12;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">//移动盒子</span><br><span class="line">currentLeft-=12;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// isLeft?currentLeft+=12:currentLeft-=12;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//把盒子现在的位置赋值给left属性</span><br><span class="line">ele.style.left=currentLeft+&quot;px&quot;;</span><br><span class="line"></span><br><span class="line">//边界检测</span><br><span class="line">if(isLeft)&#123;</span><br><span class="line">if(currentLeft&gt;=target)&#123;</span><br><span class="line">//停止运动 清除定时器</span><br><span class="line">clearInterval(ele.timeID);</span><br><span class="line">//元素复位</span><br><span class="line">ele.style.left=target+&quot;px&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(currentLeft&lt;=target)&#123;</span><br><span class="line">//停止运动 清除定时器</span><br><span class="line">clearInterval(ele.timeID);</span><br><span class="line">//元素复位</span><br><span class="line">ele.style.left=target+&quot;px&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//isLeft? ( currentLeft &gt;= target ? ( (clearInterval(ele.timeID)) &amp;&amp; (ele.style.left = target + &quot;px&quot;)): &quot;&quot;):( currentLeft &lt;= target ?( (clearInterval(ele.timeID)) &amp;&amp; (ele.style.left = target + &quot;px&quot;)): &quot;&quot;)</span><br><span class="line"></span><br><span class="line">&#125;,100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="缓速动画的封装"><a href="#缓速动画的封装" class="headerlink" title="缓速动画的封装"></a>缓速动画的封装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">function slowMOVE(ele, attrs, callback) &#123;</span><br><span class="line">//开启新的定时器之前先清除定时器</span><br><span class="line">clearInterval(ele.timeID);</span><br><span class="line">//3.开启定时器</span><br><span class="line">ele.timeID = setInterval(function() &#123;</span><br><span class="line">/*</span><br><span class="line">开关思想：</span><br><span class="line">1.提出假设</span><br><span class="line">2.验证假设</span><br><span class="line">3.根据变量的结果做出操作</span><br><span class="line">*/</span><br><span class="line">//提出假设</span><br><span class="line">var isAll = true;</span><br><span class="line">//验证假设</span><br><span class="line"></span><br><span class="line">//遍历传入的所有属性</span><br><span class="line">for (var key in attrs) &#123;</span><br><span class="line">var attr = key;</span><br><span class="line">var target = attrs[key];</span><br><span class="line"></span><br><span class="line">if (attr == &quot;zIndex&quot;||attr==&quot;backgroundColor&quot;) &#123;</span><br><span class="line">ele.style[attr] = target;</span><br><span class="line">&#125; else if (attr == &quot;opacity&quot;) &#123;</span><br><span class="line">//3.1.获取元素位置</span><br><span class="line"></span><br><span class="line">//offsetLeft 获取属性值：获取到的只是数字类型的</span><br><span class="line">//透明度是小数 不适合进行运算 所以扩大100倍</span><br><span class="line">//透明度是小数，所以使用parseFloat</span><br><span class="line">var currentLeft = (parseFloat(getEleStyle(ele, attr)))*100;</span><br><span class="line">//3.2.开始移动（在原本的位置上缓速移动）</span><br><span class="line">var speed = (target*100 - currentLeft) / 10;</span><br><span class="line"></span><br><span class="line">//消除误差</span><br><span class="line">// if(speed&gt;0)&#123;</span><br><span class="line">// speed=Math.ceil(speed);</span><br><span class="line">// &#125;else&#123;</span><br><span class="line">// speed=Math.floor(speed);</span><br><span class="line">// &#125;</span><br><span class="line">speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed);</span><br><span class="line"></span><br><span class="line">currentLeft += speed;</span><br><span class="line">//3.3将移动到的当前位置赋值给  box.style.left</span><br><span class="line">ele.style[attr] = currentLeft/100;</span><br><span class="line"></span><br><span class="line">//4.终点检测</span><br><span class="line">if (currentLeft != target) &#123;</span><br><span class="line">isAll = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">//3.1.获取元素位置</span><br><span class="line"></span><br><span class="line">//offsetLeft 获取属性值：获取到的只是数字类型的</span><br><span class="line">//而window.getComputedStyle方法获取到的是带单位的字符串</span><br><span class="line">var currentLeft = parseInt(getEleStyle(ele, attr));</span><br><span class="line">//3.2.开始移动（在原本的位置上缓速移动）</span><br><span class="line">var speed = (target - currentLeft) / 10;</span><br><span class="line"></span><br><span class="line">//消除误差</span><br><span class="line">// if(speed&gt;0)&#123;</span><br><span class="line">// speed=Math.ceil(speed);</span><br><span class="line">// &#125;else&#123;</span><br><span class="line">// speed=Math.floor(speed);</span><br><span class="line">// &#125;</span><br><span class="line">speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed);</span><br><span class="line"></span><br><span class="line">currentLeft += speed;</span><br><span class="line">//3.3将移动到的当前位置赋值给  box.style.left</span><br><span class="line">ele.style[attr] = currentLeft + &quot;px&quot;;</span><br><span class="line"></span><br><span class="line">//4.终点检测</span><br><span class="line">if (currentLeft != target) &#123;</span><br><span class="line">isAll = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//根据变量的值，给出结果</span><br><span class="line">if (isAll) &#123;</span><br><span class="line">//停止运动:清除定时器</span><br><span class="line">clearInterval(ele.timeID);</span><br><span class="line">callback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, 50)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//IE8兼容</span><br><span class="line">function getEleStyle(ele, attr) &#123;</span><br><span class="line">//做浏览器能力检测</span><br><span class="line">if (window.getComputedStyle) &#123;</span><br><span class="line">var style = window.getComputedStyle(ele, null);</span><br><span class="line">return style[attr];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return ele.currentStyle[attr];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/2022/10/29/ES6/"/>
      <url>/2022/10/29/ES6/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="ES6介绍"><a href="#ES6介绍" class="headerlink" title="ES6介绍"></a>ES6介绍</h2><p> ES6 ECMAScript 第六版</p><p>​    ECMAScript 是Javascript的一套标准化设置</p><p>​    ES6的内容包括：</p><p>​      1.声明变量的方法（let和const）</p><p>​      2.变量的结解构赋值</p><p>​      3.扩展运算符</p><p>​      4.数据劫持 箭头函数</p><p>​      5.Set Map</p><p>​      6.数组 对象 数值的扩展</p><p>​      7.Promise对象</p><p>​      8.Generator函数</p><h2 id="ES6新增语法"><a href="#ES6新增语法" class="headerlink" title="ES6新增语法"></a>ES6新增语法</h2><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>​let和const命令是ES6新增的语法</p><p>作用：是用来声明变量 和var的作用一样</p><p>let和const的用法注意点几乎一样 只是let在同一作用域内 可以重新赋值 但是不能重复声明</p><p>const声明的是常量 声明过后就不能再重新声明或者重新赋值 </p><h3 id="let声明的变量"><a href="#let声明的变量" class="headerlink" title="let声明的变量"></a>let声明的变量</h3><p>let声明的变量 只是在let所在的作用域内起作用（变量绑定）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">     a = <span class="number">456</span>;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="comment">//在下面进行let声明</span></span><br><span class="line">       <span class="keyword">let</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-------------------------&gt;报错</span></span><br></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p><strong>(1) 作用域的问题</strong></p><p> 通常情况下 如果需要一个变量在一个规定的作用域内起作用 那么就需要使用function关键字来搭建一个局部作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"> &#125;());</span><br></pre></td></tr></table></figure><p>但是在ES6的情况下 引入了let 只要存在{} 就可以形成一个块级作用域 不管是if结构 还是for循环结构 只要有{} 存在 即形成了块级作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> s=<span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure><p><strong>(2) var 声明变量 变量提升的问题</strong></p><p>需求：在函数调用时 实时的打印出当前的时间</p><p>在if结构里面使用var声明 {}没办法形成块级作用域 那么if结构里面的变量声明就会覆盖掉全局的变量声明，所以打印出来的undefined;</p><p>解决办法：在if结构里面使用let声明变量 使其在if结构里面形成一个块级作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(time);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// var time=&quot;明天是端午节&quot;;</span></span><br><span class="line">            <span class="keyword">let</span> time = <span class="string">&quot;明天是端午节&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p><strong>(3) for循环中 循环变量泄露为全局变量的问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">      &#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br></pre></td></tr></table></figure><p>js语言的一大特性：单线程 同一时间内只做一件事</p><p>任务队列：所有的任务都需要排队 前面的执行完 才会执行后面的任务</p><p>事件循环：主线程会不断循环的去任务队列里面读取任务（Event Loop）当遇到异步任务完成 或者某个事件被触发</p><p>那么相应的回调函数 或者 函数体 就会被拉到主线程里面去执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br></pre></td></tr></table></figure><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>在ES6中 按照一定的模式 从数组中提取数值 对对应的变量进行赋值的操作 就叫做解构赋值<br>本质上讲 解构赋值 就是模式匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>[a,b,c]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c); <span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.如果想要解构赋值成功 那么就必须保证两边的模式完全一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>[a,b,c]=[<span class="number">1</span>,[<span class="number">2</span>],&#123;<span class="attr">name</span>:<span class="string">&quot;lucy&quot;</span>&#125;];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c); <span class="comment">//1 Array(1) 0: 2   Object &#123;name:&quot;lucy&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>2.如果解构不成功 那么变量的值就等于undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">left[r]=[];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r); <span class="comment">//undefined 这个就像var 声明了变量之后 不进行赋值</span></span><br><span class="line"></span><br><span class="line">left[s,t]=[<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s,t) <span class="comment">//3,undefined 这个也是属于解构不成功 因为数值不够</span></span><br></pre></td></tr></table></figure><p>3.不完全解构的情况下 也可以进行解构赋值 只是后面放数值的数组都有多的数字<br>不完全解构 ：指的是等号左右两边模式一样 但是只匹配到右边的一部分数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>[x,y]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x,y); <span class="comment">//1 2</span></span><br></pre></td></tr></table></figure><p>4.如果等号右边不是数组 那么就会报错 因为模式一样</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h3><p>1.解构赋值允许设置默认值 但是如果要启用默认值 那么这个变量的值就必须严格等于undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>[a,b]=[<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span>[a,b=<span class="string">&quot;abc&quot;</span>]=[<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b); <span class="comment">//1 2</span></span><br><span class="line"><span class="keyword">let</span>[a,b=<span class="string">&quot;abc&quot;</span>]=[<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b); <span class="comment">//1  &quot;abc&quot;</span></span><br><span class="line"><span class="keyword">let</span>[a,b=<span class="string">&quot;abc&quot;</span>]=[<span class="number">1</span>,<span class="literal">null</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b); <span class="comment">//1 &quot;null&quot;</span></span><br></pre></td></tr></table></figure><p>2.如果设置的默认是一个表达式 那么这个表达式只是在需要启用默认值的时候才会运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line">        <span class="comment">// return 123</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span>[s=<span class="title function_">fn</span>()]=[<span class="number">12</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">//12</span></span><br><span class="line"><span class="keyword">let</span>[s=<span class="title function_">fn</span>()]=[];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">//undefined 这里的undefined 不是[]里面的undefined 而是fn调用之后的返回值undefined</span></span><br></pre></td></tr></table></figure><p>3.默认值可以使用其他变量 但是前提是赋值的这个变量必须是提前声明过的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span>[x=d]=[];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>[x=<span class="number">2</span>,y=x]=[];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x,y); <span class="comment">//2 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// let[x=y,y=2]=[];</span></span><br><span class="line"><span class="comment">// console.log(x,y); //报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>[x=<span class="number">2</span>,y=x]=[<span class="number">8</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x,y); <span class="comment">//8 8</span></span><br></pre></td></tr></table></figure><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符 (…)</p><p>1.直接赋值 修改了原数组的值 arr1里面的值也会发生改变 因为他们指向同一块内存空间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>];</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">1</span>]);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> arr1=arr;</span><br><span class="line">    arr[<span class="number">1</span>]=<span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([...arr]);</span><br></pre></td></tr></table></figure><p>2.使用扩展运算符 就是一个一个加到新数组里面去 所以即使原数组元素发生变化 也不会影响新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2=[...arr];</span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);</span><br></pre></td></tr></table></figure><h3 id="扩展运算符的作用"><a href="#扩展运算符的作用" class="headerlink" title="扩展运算符的作用"></a>扩展运算符的作用</h3><h5 id="1-数组合并"><a href="#1-数组合并" class="headerlink" title="1.数组合并"></a>1.数组合并</h5><p>这里不管是concat方法 还是扩展运算符 都是浅拷贝，如果修改了原数组的指向 就会同步反应到新数组 就是浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>];</span><br><span class="line">arr1[<span class="number">2</span>]=<span class="number">33</span>;</span><br><span class="line"><span class="keyword">var</span> arrCon=arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrCon)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrSp=[...arr1,...arr2];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrSp);</span><br></pre></td></tr></table></figure><p>合并后的数组和合并前的数组指向同一片内存空间 所以都是浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrSp[<span class="number">0</span>]===arr1[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrCon[<span class="number">0</span>]===arr1[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...arr2];</span><br></pre></td></tr></table></figure><h5 id="2-数组的拷贝"><a href="#2-数组的拷贝" class="headerlink" title="2.数组的拷贝"></a>2.数组的拷贝</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,[<span class="number">3</span>,[<span class="number">12</span>,<span class="number">15</span>,[<span class="number">15</span>,<span class="number">18</span>]]],&#123;<span class="attr">name</span>:<span class="string">&quot;lili&quot;</span>&#125;];</span><br><span class="line">        <span class="keyword">var</span> arrSp=[...arr];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arrSp)</span><br><span class="line"></span><br><span class="line">        arr[<span class="number">2</span>].<span class="property">name</span>=<span class="string">&quot;zs&quot;</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arrSp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> str=<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr);</span><br><span class="line">        <span class="keyword">var</span> arr2=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line">        arr[<span class="number">2</span>].<span class="property">name</span>=<span class="string">&quot;lucy&quot;</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);</span><br></pre></td></tr></table></figure><h5 id="3-与解构赋值相结合"><a href="#3-与解构赋值相结合" class="headerlink" title="3.与解构赋值相结合"></a>3.与解构赋值相结合</h5><p>如果是普通变量 那么就按照模式赋值 如果使用了扩展运算符 那么就是后面的值依次放入数组</p><p>如果等号右边是空数组 那么仅仅是声明 变量就是undefined 数组就是[]</p><p>（1）与解构赋值相结合 给变量和数组赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [s,...t]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(s,t);  <span class="comment">//1 [2,3,4,5]</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> [s,...t]=[]  <span class="comment">//undefined []</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(s,t);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//就相当于 </span></span><br><span class="line">       <span class="comment">// var a;</span></span><br><span class="line">       <span class="comment">// var arr=[]</span></span><br></pre></td></tr></table></figure><p>(2).将扩展运算符用于数组赋值 只能放在参数的最后一位 否则就会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>[a,...b,c]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span>[...b,a,c]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c) <span class="comment">//Rest element must be last element</span></span><br></pre></td></tr></table></figure><p>(3) 扩展运算符可以将字符串转成真正的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...<span class="string">&quot;hello&quot;</span>]);</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure><p>（4）只有函数调用时 扩展运算符才可以放在圆括号里面 否则这种写法就直接报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="number">12</span>,<span class="number">45</span>,<span class="number">25</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(...arr1); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...arr1]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((...arr1)); <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr1); <span class="comment">//把数组中的数 一个一个取出来</span></span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="1-对象属性的扩展"><a href="#1-对象属性的扩展" class="headerlink" title="1.对象属性的扩展"></a>1.对象属性的扩展</h3><p>1.对象属性的简单赋值方式  可以将变量名直接放进对象中, 解析的时候  将变量名解析为属性名  变量值解析为属性值</p><p>2.对象方法的简单赋值  可以省略function关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;喻文波&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> gender = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> p = &#123;</span><br><span class="line">      <span class="comment">//原来</span></span><br><span class="line">      <span class="comment">// name : name,</span></span><br><span class="line">      <span class="comment">// age : age,</span></span><br><span class="line">     <span class="comment">//ES6中的简单赋值</span></span><br><span class="line">      name,</span><br><span class="line">     gender,</span><br><span class="line">      <span class="comment">// adc : function()&#123;</span></span><br><span class="line">      <span class="comment">//   console.log(&quot;伊泽瑞尔&quot;);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">//2.对象方法的简单写法</span></span><br><span class="line">      <span class="title function_">adc</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;伊泽瑞尔&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p.<span class="title function_">adc</span>();</span><br></pre></td></tr></table></figure><p>3.super关键字：指向当前对象的原型对象</p><p>使用注意点 : </p><ol><li>只能在对象的方法中使用  在其他地方使用都会报错</li><li>只能在对象方法的简写方式中使用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        name : <span class="string">&quot;宋义进&quot;</span>,</span><br><span class="line">        <span class="attr">girlFriend</span>:<span class="string">&quot;刘亦菲&quot;</span>,</span><br><span class="line">        <span class="comment">// job : function() &#123;</span></span><br><span class="line">        <span class="comment">//     console.log(&quot;我是&quot;+super.type+&quot;中单&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">job</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是&quot;</span>+<span class="variable language_">super</span>.<span class="property">type</span>+<span class="string">&quot;中单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.<span class="property">__proto__</span>=&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;star&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    obj.<span class="title function_">job</span>();</span><br></pre></td></tr></table></figure><p>4.对象的计算属性名  使用方式[]  对属性名进行计算, 里面可以是变量名  表达式 也可以是函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">   <span class="keyword">var</span> n2 = <span class="string">&quot;age&quot;</span>;</span><br><span class="line">   <span class="keyword">var</span> n3 = <span class="string">&quot;hobby&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">getGender</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;gender&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       [n1]:<span class="string">&quot;老师&quot;</span>,</span><br><span class="line">       [n2]:<span class="number">20</span>,</span><br><span class="line">       <span class="comment">// [n3]:function()&#123;</span></span><br><span class="line">       <span class="comment">//     console.log(&quot;我的爱好是跑步&quot;); </span></span><br><span class="line">       <span class="comment">// &#125;,</span></span><br><span class="line">       [n3]()&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>[n1]+ <span class="string">&quot;---&quot;</span> +<span class="variable language_">this</span>[n2]);</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">       [<span class="title function_">getGender</span>()]:<span class="string">&quot;男&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   obj[n3]();</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="title function_">getGender</span>()]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-对象的新增的api"><a href="#2-对象的新增的api" class="headerlink" title="2.对象的新增的api"></a>2.对象的新增的api</h3><p> &#x2F;&#x2F;1.Object.is() 这个方法和js的严格判断(&#x3D;&#x3D;&#x3D;)用法基本一样 只是在对于-0和+0 以及NaN的判断上做了改善</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> === +<span class="number">0</span>);<span class="comment">//ture =======&gt; 需要他是false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>);<span class="comment">//false ======&gt;需要他是true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> === +<span class="number">0</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>  <strong>&#x2F;&#x2F;2.Object.assign() 是用来合并对象的</strong></p><p><strong>注意点 :</strong> </p><ol><li>该方法的返回值一定传入的第一个参数, 会把后面的参数全都合并上去之后返回</li><li>第一个参数必须是对象  如果是基本数据类型 就转换成对应的包装类返回</li><li>如果第一个参数是undefined 或者null 因为他们无法转换成对象  那么就会报错</li><li>如果合并的对象里面有同名的属性 那么后面的就会覆盖前面的</li><li>如果有两个参数  undefined 或者null不作为第一个参数  那么就回原值第一个参数</li><li>Object.assign方法是浅拷贝 不是深拷贝</li></ol><p>  &#x2F;&#x2F;参数1:目标对象  参数2…. : 需要合并的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var name = &#123;&quot;name&quot; : &quot;张学友&quot;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var name = &quot;[Object object]&quot;;</span></span><br></pre></td></tr></table></figure><p>3.Object.setPrototypeOf()  设置一个对象的原型对象</p><p>参数1 : 目标对象   参数2  : 新设置原型的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">n1</span>:<span class="number">15</span>,</span><br><span class="line">    <span class="attr">n2</span>:<span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br></pre></td></tr></table></figure><p>4.Object.getPrototypeOf()  获取一个对象的原型对象</p><p>参数 : 需要获取对象的原型的对象名</p><p><code> console.log(Object.getPrototypeOf(obj));</code></p><p>5.Object.keys()   是将对象所有的属性名获取到 添加到数组  并返回  返回的是一个数组  </p><p>参数 : 需要遍历的对象名</p><p>6.Object.values()  是将对象所有的属性值获取到 添加到数组  并返回  返回的是一个数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">work</span>:<span class="string">&quot;无业游民&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(stu));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(stu));</span><br></pre></td></tr></table></figure><h2 id="class关键字的基本使用"><a href="#class关键字的基本使用" class="headerlink" title="class关键字的基本使用"></a>class关键字的基本使用</h2><h3 id="1-传统的构造函数的问题"><a href="#1-传统的构造函数的问题" class="headerlink" title="1.传统的构造函数的问题 :"></a>1.传统的构造函数的问题 :</h3><p>​     1. 构造函数和原型方法属性分离 不便于维护 降低了可读性</p><p>​     2. 原型对象的成员可以遍历</p><pre><code> 3. 默认情况下构造函数也是可以被当做普通函数来调用的 所以 功能性不明显    4. 原型中的方法也可以作为构造函数来用</code></pre><h3 id="2-类的用法"><a href="#2-类的用法" class="headerlink" title="2.类的用法"></a>2.类的用法</h3><p>let和const一样 都有暂时性死区 必须先定义 再使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">name, sex</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;,&quot;</span> + <span class="variable language_">this</span>.<span class="property">sex</span>; </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lily&quot;</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> c1 = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure><h3 id="3-ES6中的类的本质"><a href="#3-ES6中的类的本质" class="headerlink" title="3.ES6中的类的本质"></a>3.ES6中的类的本质</h3><p>class就是一个语法糖 本质就是一个函数 就是使用ES5里面的函数封装的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, sex</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;<span class="comment">// this指向于类创建的实例化对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">     concole.<span class="title function_">log</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span>  <span class="title class_">Person</span>);  <span class="comment">// function</span></span><br></pre></td></tr></table></figure><h3 id="4-类的特点"><a href="#4-类的特点" class="headerlink" title="4.类的特点"></a>4.类的特点</h3><ol><li><p>类是不可枚举的</p></li><li><p>类的用法很let和const一样 都有暂时性死区 必须先定义 再使用</p></li><li><p>类里面的方法不能做为构造函数来使用 </p></li><li><p>类(Person)使用的时候 必须配合new关键字进行使用 否则就会报错</p></li></ol><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><h3 id="ES5之前拼接的字符串"><a href="#ES5之前拼接的字符串" class="headerlink" title="ES5之前拼接的字符串"></a>ES5之前拼接的字符串</h3><p>  1.拼接太麻烦 需要多次分割 不便于维护</p><p>  2.所有拼接的字符串只能一行 显示 太长</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;p&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;我叫&quot;</span> + stu.<span class="property">name</span> + <span class="string">&quot;,我今年&quot;</span>+stu.<span class="property">age</span> +<span class="string">&quot;岁了,我住在&quot;</span>+stu.<span class="property">place</span> + <span class="string">&quot;,今年上&quot;</span>+stu.<span class="property">grade</span>+<span class="string">&quot;年级了&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;p&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;我叫&quot;</span> + stu.<span class="property">name</span> + <span class="string">&quot;,我今年&quot;</span>+stu.<span class="property">age</span> +<span class="string">&quot;岁,我住在&quot;</span>+stu.<span class="property">place</span> + <span class="string">&quot;,今年上&quot;</span>+stu.<span class="property">grade</span>+<span class="string">&quot;年级了&quot;</span>;</span><br></pre></td></tr></table></figure><p>3.所有的内容写在反引号(&#96;&#96;)里面 然后变量放在${}里面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;p&quot;</span>).<span class="property">innerHTML</span> = <span class="string">`我叫<span class="subst">$&#123;stu.name&#125;</span>,我今年<span class="subst">$&#123;stu.age&#125;</span>岁了,我住在<span class="subst">$&#123;stu.place&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>4.在${}可以放入任意的js表达式  可以进行运算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">age</span>(<span class="params">num</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> num - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><h3 id="模板引擎的介绍"><a href="#模板引擎的介绍" class="headerlink" title="模板引擎的介绍"></a>模板引擎的介绍</h3><p>页面渲染使用字符串拼接 会存在问题 : 字符的恒定性 字符串拼接的时候容易出错</p><p>模板引擎不用拼接字符串 直接使用 静态页面里面的html里面的结构生成模板 需要渲染的时候直接调用</p><p>模板引擎的实现方式有很多，最简单的是“置换型”模板引擎，这类模板引擎只是将指定模板内容（字符串）中的特定标记（子字符串）替换一下便生成了最终需要的业务数据（比如网页）。</p><h3 id="模板引擎的使用步骤"><a href="#模板引擎的使用步骤" class="headerlink" title="模板引擎的使用步骤"></a>模板引擎的使用步骤</h3><ol><li><p>导入模板引擎</p></li><li><p>准备一个模板</p></li></ol><p>​       2.1. 准备模板必须要是用script  模板引擎规定的只能使用script</p><p>​       2.2. 必须要给他一个id 在调用方法的时候使用</p><p>​      2.3. 必须要有type属性 而且type属性绝对绝对不能使text&#x2F;javascript</p><ol start="3"><li>调用方法 生成html结构</li></ol><h3 id="模板引擎使用的注意点"><a href="#模板引擎使用的注意点" class="headerlink" title="模板引擎使用的注意点:"></a>模板引擎使用的注意点:</h3><ol><li><p>代入的时候 一定要注意 代入的名字一定要和对象的属性名一直</p></li><li><p>type的值只要不是text&#x2F;javascript 但是建议使用text&#x2F;html 因为其他的没办法识别标签</p></li><li><p>&lt;%&#x3D; %&gt; 必须是一个完整的整体 不能加空格 或者其他的符号</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu = &#123;</span><br><span class="line">            name : <span class="string">&quot;lisa&quot;</span>,</span><br><span class="line">            age : <span class="number">18</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> html = <span class="title function_">template</span>(<span class="string">&quot;tpl&quot;</span>, stu);</span><br></pre></td></tr></table></figure><h2 id="模板引擎的简写方式"><a href="#模板引擎的简写方式" class="headerlink" title="模板引擎的简写方式"></a>模板引擎的简写方式</h2><p>1.导入引擎模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./js/template-web.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2.准备模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; each list value &#125;&#125;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; value.Id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; value.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line">            &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; value.age &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span> --&gt;</span><br><span class="line">            &#123;&#123;<span class="keyword">if</span> value.<span class="property">age</span> &gt;= <span class="number">18</span>&#125;&#125;</span><br><span class="line">            &lt;td&gt;成年&lt;/td&gt;</span><br><span class="line">            &#123;&#123; <span class="keyword">else</span> &#125;&#125;</span><br><span class="line">            &lt;td&gt;未成年&lt;/td&gt;</span><br><span class="line">            &#123;&#123; /<span class="keyword">if</span> &#125;&#125;</span><br><span class="line">            &lt;td&gt;&#123;&#123; value.<span class="property">score</span> &#125;&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &#123;&#123; /each &#125;&#125;</span><br></pre></td></tr></table></figure><p> 3.调用方法生成模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="title function_">template</span>(<span class="string">&quot;tpl&quot;</span>, &#123; <span class="attr">list</span>: arr &#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#tb&quot;</span>).<span class="property">innerHTML</span> = html;</span><br></pre></td></tr></table></figure><h2 id="模板引擎的语法和输出"><a href="#模板引擎的语法和输出" class="headerlink" title="模板引擎的语法和输出"></a>模板引擎的语法和输出</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>标准语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="keyword">if</span> user&#125;&#125;</span><br><span class="line">&lt;h2&gt;&#123;&#123;user.<span class="property">name</span>&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>原始语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (user) &#123; %&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&lt;%= user.name %&gt;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="1-输出"><a href="#1-输出" class="headerlink" title="1.输出"></a>1.输出</h4><p><strong>标准语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;value&#125;&#125;</span><br><span class="line">&#123;&#123;data.<span class="property">key</span>&#125;&#125;</span><br><span class="line">&#123;&#123;data[<span class="string">&#x27;key&#x27;</span>]&#125;&#125;</span><br><span class="line">&#123;&#123;a ? b : c&#125;&#125;</span><br><span class="line">&#123;&#123;a || b&#125;&#125;</span><br><span class="line">&#123;&#123;a + b&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>原始语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= value %&gt;</span><br><span class="line">&lt;%= data.<span class="property">key</span> %&gt;</span><br><span class="line">&lt;%= data[<span class="string">&#x27;key&#x27;</span>] %&gt;</span><br><span class="line">&lt;%= a ? b : c %&gt;</span><br><span class="line">&lt;%= a || b %&gt;</span><br><span class="line">&lt;%= a + b %&gt;</span><br></pre></td></tr></table></figure><h4 id="2-原文输出"><a href="#2-原文输出" class="headerlink" title="2.原文输出"></a>2.原文输出</h4><p><strong>标准输出</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;@ value&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>原始输出</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- value %&gt;</span><br></pre></td></tr></table></figure><h4 id="3-条件输出"><a href="#3-条件输出" class="headerlink" title="3.条件输出"></a>3.条件输出</h4><p><strong>标准语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 单 <span class="keyword">if</span> 判断 --&gt;</span><br><span class="line">&#123;&#123;<span class="keyword">if</span> value&#125;&#125; </span><br><span class="line">... </span><br><span class="line">&#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="keyword">if</span> ... <span class="keyword">else</span> ... 判断 --&gt;</span><br><span class="line">&#123;&#123;<span class="keyword">if</span> v1&#125;&#125; </span><br><span class="line">... </span><br><span class="line">&#123;&#123;<span class="keyword">else</span> <span class="keyword">if</span> v2&#125;&#125;</span><br><span class="line"> ... </span><br><span class="line">&#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>原始语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 单 <span class="keyword">if</span> 判断 --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (value) &#123; %&gt;</span><br><span class="line">...</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="keyword">if</span> ... <span class="keyword">else</span> ... 判断 --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (v1) &#123; %&gt;</span><br><span class="line">...</span><br><span class="line">&lt;% <span class="keyword">else</span> <span class="keyword">if</span> (v2) &#123; %&gt;</span><br><span class="line">...</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="4-循环输出"><a href="#4-循环输出" class="headerlink" title="4.循环输出"></a>4.循环输出</h4><p><strong>标准语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;each target&#125;&#125;</span><br><span class="line">  &#123;&#123;$index&#125;&#125; &#123;&#123;$value&#125;&#125;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>target</code>是一个数组，<code>each</code>用于对数组遍历，<code>$index</code> 是数组的下标， <code>$value</code>是数组的值<br> <strong>原始语法</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; i++) &#123; %&gt;</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>自我介绍<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>大家好, 我叫&lt;%= list[i].name %&gt;, 我今年&lt;% if(list[i].age &gt; 20) &#123; %&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">u</span>&gt;</span>成年<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">               &lt;% &#125; else &#123; %&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">u</span>&gt;</span>未成年<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           &lt;% &#125; %&gt; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li><code>target</code> 支持 <code>array</code> 与<code>object</code> 的迭代，其默认值为 <code>$data</code>。</li></ol><h2 id="模板字符串标记"><a href="#模板字符串标记" class="headerlink" title="模板字符串标记"></a>模板字符串标记</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标记名<span class="string">`模板字符串`</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = myTag<span class="string">`邓哥喜欢<span class="subst">$&#123;love1&#125;</span>，邓哥也喜欢<span class="subst">$&#123;love2&#125;</span>。`</span>;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="title function_">myTag</span>([<span class="string">&quot;邓哥喜欢&quot;</span>, <span class="string">&quot;，邓哥也喜欢&quot;</span>, <span class="string">&quot;。&quot;</span>], <span class="string">&quot;秋葵&quot;</span>, <span class="string">&quot;香菜&quot;</span>)</span><br><span class="line"><span class="comment">//每一位的的字符串都会合并作为数组</span></span><br><span class="line"><span class="comment">//每一位的表达式都会作为剩余参数储存起来</span></span><br></pre></td></tr></table></figure><h2 id="字符串中的api"><a href="#字符串中的api" class="headerlink" title="字符串中的api"></a>字符串中的api</h2><h3 id="1-indexof"><a href="#1-indexof" class="headerlink" title="1.indexof"></a>1.indexof</h3><p>是查找字符串中是否包含某一个字符串</p><p>参数1：需要查询的目标字符串   参数2：就是开始查询的索引(如果不写 默认从0开始)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;符合安静的染色剂大连房价垃圾费&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;安静&quot;</span>));   <span class="comment">//2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;安静&quot;</span>),<span class="number">5</span>); <span class="comment">//-1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;安宁&quot;</span>));<span class="comment">//-1</span></span><br></pre></td></tr></table></figure><h3 id="2-includes"><a href="#2-includes" class="headerlink" title="2.includes()"></a>2.includes()</h3><p>检测字符串或者数组中是否包含某一个字符串或者元素</p><p>返回值:布尔类型</p><p>参数1:需要查询的目标字符串 参数2:就是开始查询的索引(如果不写 默认从0开始)</p><p> indexOf 和 includes 的区别:</p><p> (1). 返回值 indexOf方法 返回找到的第一个子字符串位置为索引 includes 找到了就返回true 没有就返回false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr.<span class="title function_">includes</span>(<span class="number">60</span>))&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;咱们有踩线及格的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rr.<span class="title function_">indexOf</span>(<span class="number">60</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;咱们有踩线及格的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">includes</span>(<span class="string">&quot;人家&quot;</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">includes</span>(<span class="string">&quot;安静&quot;</span>,<span class="number">12</span>));</span><br></pre></td></tr></table></figure><p>(2)如果数组里面包含NaN 但是我们又正好需要查数组里面有没有NaN  那么indexfo就不能用 就只能使用includes</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">15</span>,<span class="number">46</span>,<span class="number">42</span>,<span class="title class_">NaN</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>));   <span class="comment">//-1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1.<span class="title function_">includes</span>(<span class="title class_">NaN</span>));  <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><p>(3)如果数组里面包含空值 那么使用indexof判断就会出错  只能使用includes</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2.<span class="title function_">indexOf</span>(<span class="literal">undefined</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2.<span class="title function_">includes</span>(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="3-startsWith-endsWith"><a href="#3-startsWith-endsWith" class="headerlink" title="3.startsWith() endsWith()"></a>3.startsWith() endsWith()</h3><p>判断是否已某一个字符串开头 或者结尾</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHi = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(sayHi . <span class="title function_">startsWith</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( sayHi . <span class="title function_">endsWith</span>(<span class="string">&quot;!&quot;</span>));</span><br></pre></td></tr></table></figure><p>  &#x2F;&#x2F;第二个参数:</p><p>&#x2F;&#x2F; startsWith :第二个参数表示从索引为几的字符串开始找</p><p>&#x2F;&#x2F; endsWith :第二个参数表示的是从索引为n之前的元素里面去找(不算自身的)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( sayHi.<span class="title function_">startsWith</span>(<span class="string">&quot;hel1o&quot;</span>, <span class="number">3</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( sayHi.<span class="title function_">endsWith</span>(<span class="string">&quot;!&quot;</span>, <span class="number">11</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayHi. <span class="title function_">endsWith</span>(<span class="string">&quot;!&quot;</span>, <span class="number">16</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><p>标签模板 本质上不是模板 而是函数的另外的一种调用形式 其实所说的标签 就是事先封装好的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">      <span class="keyword">var</span> sex = <span class="string">&quot;boy&quot;</span>;</span><br><span class="line">      <span class="keyword">var</span> girl = <span class="string">&quot;sex girl&quot;</span>;</span><br><span class="line">      <span class="keyword">var</span> feature = <span class="string">&quot;cool&quot;</span>;</span><br><span class="line">      <span class="keyword">var</span> hi = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">`My name is <span class="subst">$&#123;name&#125;</span>,I am a <span class="subst">$&#123;sex&#125;</span>, I have a <span class="subst">$&#123;girl&#125;</span>`</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br></pre></td></tr></table></figure><p>参数就是他后面接的字符串 以${}为分隔符 固定的字符串 放进数组里面 然后${}里面的变量依次作为后面的参数</p><p>标记模板（函数）的参数：</p><p>参数1 被插入的变量分割而成字符串数组</p><p>参数2…….n 都是被插入的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">intro</span>(<span class="params">parts</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(parts);</span><br><span class="line">         <span class="comment">// [&quot;&quot;, &quot;,My name is &quot;, &quot;,I am a &quot;, &quot; &quot;, &quot;, I have a &quot;, &quot;&quot;]</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// console.log(a1);</span></span><br><span class="line">         <span class="comment">// console.log(a2);</span></span><br><span class="line">         <span class="comment">// console.log(a3);</span></span><br><span class="line">         <span class="comment">// console.log(a4);</span></span><br><span class="line"></span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">         <span class="comment">// 0: (6) [&quot;&quot;, &quot;,My name is &quot;, &quot;,I am a &quot;, &quot; and &quot;, &quot;, I have a &quot;, &quot;&quot;]</span></span><br><span class="line">         <span class="comment">// 1: &quot;hello&quot;</span></span><br><span class="line">         <span class="comment">// 2: &quot;jack&quot;</span></span><br><span class="line">         <span class="comment">// 3: &quot;cool&quot;</span></span><br><span class="line">         <span class="comment">// 4: &quot;boy&quot;</span></span><br><span class="line">         <span class="comment">// 5: &quot;sex girl&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">// [&quot;hello&quot;, &quot;jack&quot;, &quot;cool&quot;, &quot;boy&quot;, &quot;sex girl&quot;]</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">             s += <span class="string">`<span class="subst">$&#123;parts[i]&#125;</span><span class="subst">$&#123;arr[i]&#125;</span>`</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         s += <span class="string">`<span class="subst">$&#123;parts[parts.length - <span class="number">1</span>]&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// var str = intro`My name is $&#123;name&#125;,I am a $&#123;sex&#125;, I have a $&#123;girl&#125;`;</span></span><br><span class="line">     <span class="keyword">var</span> str = intro<span class="string">`<span class="subst">$&#123;hi&#125;</span>,My name is <span class="subst">$&#123;name&#125;</span>,I am a <span class="subst">$&#123;feature&#125;</span> <span class="subst">$&#123;sex&#125;</span>, I have a <span class="subst">$&#123;girl&#125;</span>`</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br></pre></td></tr></table></figure><h2 id="函数的拓展"><a href="#函数的拓展" class="headerlink" title="函数的拓展"></a>函数的拓展</h2><h3 id="给参数设置默认值"><a href="#给参数设置默认值" class="headerlink" title="给参数设置默认值"></a>给参数设置默认值</h3><p>ES6里面默认给参数设置默认值</p><p>1.为了防止报错 我们不用再特地在函数内部处理参数</p><p>2.设置了默认值 即使所有的参数都不传 我们的程序也不会报错</p><p><code>注意点</code>:参数是在函数的局部作用域内设置的局部变量 默认是在函数内部声明过的 所以不要再使用let在函数内部声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">m = <span class="number">20</span>, n = <span class="number">30</span></span>) &#123;</span><br><span class="line">  <span class="comment">// let n = 80;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(m + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">count</span>();</span><br></pre></td></tr></table></figure><h3 id="函数拓展的应用"><a href="#函数拓展的应用" class="headerlink" title="函数拓展的应用"></a>函数拓展的应用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">* @param name 是需要创建的标签的标签名</span><br><span class="line">    * @param container 是需要盛装新建的元素的盒子</span><br><span class="line">    * @param content  设置给新增元素的文本</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getContainer</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">name = <span class="string">&quot;p&quot;</span>, container = getContainer(<span class="string">&quot;container&quot;</span>), content = <span class="string">&quot;你好世界&quot;</span></span>) &#123;</span><br><span class="line">        <span class="comment">//创建一个对象</span></span><br><span class="line">        <span class="keyword">var</span> ele = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加属性或内容</span></span><br><span class="line">        ele.<span class="property">innerHTML</span> = content;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加页面上</span></span><br><span class="line">        container.<span class="title function_">appendChild</span>(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>), <span class="string">&quot;你好世界&quot;</span>);</span><br><span class="line">    <span class="title function_">createElement</span>();</span><br><span class="line">    <span class="title function_">createElement</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="string">&quot;今天天气好晴朗&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>&#x3D;&gt; 箭头函数</strong> </p><p>ES6是允许使用箭头函数的</p><p>​1.只有一个参数 并且函数体只有一句话 那么参数可以省略() 返回值可以省略return 函数体省略了{}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">fn</span> = n =&gt; <span class="number">123</span>;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">n</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>2.如果箭头函数没有参数 或者有多个参数 那么参数中的()就不能省略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">study</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 3.如果箭头函数的函数体有多条代码 那么就不能省略&#123;&#125; 以及返回值也不能省略return</span></span><br><span class="line">   <span class="keyword">var</span> lesson = <span class="string">&quot;语文&quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;好好学习天天向上&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//改成箭头函数</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">study</span> = (<span class="params"></span>) =&gt;&#123;</span><br><span class="line"> <span class="keyword">var</span> lesson = <span class="string">&quot;语文&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;好好学习天天向上&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>4.如果函数体只有一句话,并且返回值是对象 那么 这个返回值必须使用()包起来 </p><p>因为 函数体使用的是{} 对象也是{}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">info</span> = (<span class="params">name,age</span>) =&gt;(&#123;</span><br><span class="line">  <span class="attr">name</span>:name,</span><br><span class="line">  <span class="attr">age</span>:age</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;茜茜&quot;</span>,<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>  如果对象只是一个键值对, 那么不会报错 但是也没有正确的值</p><p>  因为js引擎在解析的时候 {}默认解析为函数体结构 函数代码 name : name;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">p</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">   <span class="attr">name</span>:name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;lili&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="函数中的this指向"><a href="#函数中的this指向" class="headerlink" title="函数中的this指向"></a>函数中的this指向</h2><h4 id="ES5中函数的this指向"><a href="#ES5中函数的this指向" class="headerlink" title="ES5中函数的this指向"></a>ES5中函数的this指向</h4><p>1.普通函数的this:this就是谁调用 this就指向谁 this是在调用的时候确定的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">f1</span>();</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">f1</span>();</span><br></pre></td></tr></table></figure><p>2.对象里面的方法 它里面的this 指向当前这个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="string">&quot;111&quot;</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="string">&quot;222&quot;</span>,</span><br><span class="line">        <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.<span class="title function_">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fn1 = obj.<span class="property">print</span>;</span><br><span class="line">    <span class="keyword">var</span> fn2 = obj.<span class="title function_">print</span>();</span><br><span class="line"></span><br><span class="line">    fnw = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">fnw</span>();<span class="comment">//this指向window</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="property">f2</span> = f1;</span><br><span class="line">    obj.<span class="title function_">f2</span>();<span class="comment">//this指向obj</span></span><br></pre></td></tr></table></figure><p>3.定时器里面的this,如果没有特殊的指向 那么 setInterval和setTimeout里面的回调函数的this一定是指向window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="string">&quot;111&quot;</span>,</span><br><span class="line">            <span class="attr">b</span>: <span class="string">&quot;222&quot;</span>,</span><br><span class="line">            <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2222</span>);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(f1, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">print</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="title function_">print</span>(), <span class="number">1000</span>); <span class="comment">//这里运行打印出this是obj 和定时器没有任何关系 只是把obj.print()调用了一遍</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.在ES6里面 箭头函数的this指向 是继承自父级执行上下文中的this</p><p> 箭头函数没有自己的this, 他的this是从父级继承而来的 箭头函数的this在定义的时候就已经确定了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;我在window里面&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;我在obj里面的&quot;</span>,</span><br><span class="line">        <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">            <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);<span class="comment">//&quot;我是obj里面的&quot;</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">name</span>);<span class="comment">//&quot;我是obj里面的&quot;</span></span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>5.构造函数里面的this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  (1)把构造函数当成普通函数调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>  (2)作为构造函数 this就指向new关键字创建的实例化对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">16</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">name</span>);<span class="comment">//&quot;张三&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>);<span class="comment">//&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>  (3)当做为构造函数时 返回值默认是new关键字创建的实例化对象 但是 如果手动添加了返回值 那么 如果是基本数据类型 就不会影响 如果是复杂数据类型 那么就会覆盖掉默认的返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);    </span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="attr">name</span>:<span class="string">&quot;1111&quot;</span>,</span><br><span class="line">     <span class="attr">age</span>:<span class="number">111</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">return</span> [<span class="number">12</span>,<span class="number">13</span>,<span class="number">15</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;丽丽&quot;</span>,<span class="number">15</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">age</span>);</span><br></pre></td></tr></table></figure><h4 id="ES6中函数的this指向"><a href="#ES6中函数的this指向" class="headerlink" title="ES6中函数的this指向"></a>ES6中函数的this指向</h4><p>在ES6里面  箭头函数的this指向 是继承自父级执行上下文中的this</p><p>​    箭头函数没有自己的this, 他的this是从父级继承而来的 箭头函数的this在定义的时候就已经确定了 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> name = <span class="string">&quot;我在window里面&quot;</span>;</span><br><span class="line">     <span class="keyword">var</span> obj = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;我是obj里面的&quot;</span>,</span><br><span class="line">        <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line"><span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// &quot;我是obj里面的&quot; </span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">name</span>); <span class="comment">// &quot;我是obj里面的&quot; </span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把fn也换成箭头函数</span></span><br><span class="line">      <span class="keyword">var</span> name = <span class="string">&quot;我在window里面&quot;</span>;</span><br><span class="line">      <span class="keyword">var</span> obj = &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&quot;我是obj里面的&quot;</span>,</span><br><span class="line">          <span class="attr">fn</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">              <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">              <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);  <span class="comment">// &quot;我在window里面&quot;</span></span><br><span class="line">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">name</span>);  <span class="comment">// &quot;我在window里面&quot; </span></span><br><span class="line">              &#125;, <span class="number">1000</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      obj.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>普通函数 : this是在调用的时候确定  谁调用 this就指向谁</p><p>箭头函数 : this是在声明的时候就已经确定 而且不会改变  this是继承自父级执行上下文的this</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><h3 id="Symbol的描述和写法"><a href="#Symbol的描述和写法" class="headerlink" title="Symbol的描述和写法"></a>Symbol的描述和写法</h3><p>Symbol 是ES6新引入的一种基本数据类型 表示的是独一无二的值 他是js里面第六种基本数据类型</p><p>​    基本数据类型 : string number boolean undefined null </p><p>​    typeof 的返回值 string number boolean undefined object function</p><ol><li>Symbol函数生成的数据 是独一无二的 即便参数一样 那么表示的值也不一样，给symbol加参数 只是为了对于这个数据进行描述</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>(<span class="string">&quot;www&quot;</span>) === <span class="title class_">Symbol</span>(<span class="string">&quot;www&quot;</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>() === <span class="title class_">Symbol</span>());</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Symbol没有字面量的写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>, <span class="number">15</span>, <span class="number">45</span>];</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>他是新增的一种数据类型 使用typeof检测 返回值是symbol</li></ol></li><li><p>Symbol数据不能使用new关键字来创建</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> <span class="title class_">Symbol</span>();  <span class="comment">// Symbol is not a constructor</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s3);</span><br></pre></td></tr></table></figure><ol start="5"><li>一般我们在创建数据的时候 最好加一个参数便于区分</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">   <span class="keyword">var</span> s2 = <span class="title class_">Symbol</span>();</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(s1);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(s2);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       a : <span class="string">&quot;123&quot;</span>,</span><br><span class="line">       b : <span class="string">&quot;456&quot;</span>,</span><br><span class="line">       [s1] : <span class="number">15</span>  <span class="comment">// 符号属性</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>6.Symbol里面的for方法</p><p>参数是一个字符串，如果有值，就将这个值返回，如果没有，就新创建一个数值(是在全局作用域内添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="title class_">Symbol</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">   <span class="keyword">var</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">   <span class="keyword">var</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2); <span class="comment">//true</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>(<span class="string">&quot;bbb&quot;</span>) === <span class="title class_">Symbol</span>(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line">   <span class="comment">//false</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(s1); <span class="comment">//Symbol(aaa)</span></span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     name : <span class="string">&quot;工藤新一&quot;</span>,</span><br><span class="line">     age : <span class="number">17</span>,</span><br><span class="line">     [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;handsome&quot;</span>)] : <span class="string">&quot;男&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;handsome&quot;</span>)]); <span class="comment">//男</span></span><br></pre></td></tr></table></figure><p>7.Symbol.keyFor </p><p>这个方法返回 已经在全局作用域登记了的Symbol值得标记参数，如果没有登记，就返回undefined</p><p>​      </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> syb1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(syb1)); <span class="comment">//sss</span></span><br><span class="line">      <span class="keyword">var</span> syb2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(syb2)); <span class="comment">//sss</span></span><br></pre></td></tr></table></figure><h3 id="ES6新增的方法-Object-get"><a href="#ES6新增的方法-Object-get" class="headerlink" title="ES6新增的方法 Object.get"></a>ES6新增的方法 Object.get</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> syb = <span class="title class_">Symbol</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">       <span class="keyword">var</span> obj = &#123;</span><br><span class="line">           a : <span class="string">&quot;123&quot;</span>,</span><br><span class="line">           b : <span class="string">&quot;456&quot;</span>,</span><br><span class="line">           [syb] : <span class="number">25</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(key);<span class="comment">// a   b       获取不到[syb] </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj));<span class="comment">//[&quot;a&quot; , &quot;b&quot;]      获取不到[syb]</span></span><br><span class="line">      </span><br><span class="line">       <span class="comment">// ES6新增的方法 Object.get</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj));<span class="comment">//[&quot;a&quot; , &quot;b&quot;] 获取不到[syb]</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj));<span class="comment">//[Symbol(c)]</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> s = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="number">0</span>] === syb);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="ES6的Set的基本用法"><a href="#ES6的Set的基本用法" class="headerlink" title="ES6的Set的基本用法"></a>ES6的Set的基本用法</h2><p><strong>使用方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();<span class="comment">//他的返回值是一个Boolean值</span></span><br></pre></td></tr></table></figure><h3 id="1-增-add-数据"><a href="#1-增-add-数据" class="headerlink" title="1.增 add(数据)"></a>1.增 add(数据)</h3><p>添加一个数据到集合的末尾 如果这个数字原本就存在，那就不进行任何操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $add = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">      $add.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">      $add.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">      $add.<span class="title function_">add</span>(<span class="number">5</span>);</span><br><span class="line">      $add.<span class="title function_">add</span>(<span class="number">5</span>); <span class="comment">//这条数据无效添加，因为已经有了这个数据</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>($add);</span><br><span class="line">      <span class="comment">//set使用object.is来判断两个值是否相等，但是专门针对-0 和  +0做了处理，在set里面默认他们相等</span></span><br><span class="line">      $add.<span class="title function_">add</span>(-<span class="number">0</span>);</span><br><span class="line">      $add.<span class="title function_">add</span>(+<span class="number">0</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>($add); <span class="comment">//-0和+0也只加入了一个</span></span><br><span class="line"></span><br><span class="line">      $add.<span class="title function_">add</span>(<span class="title class_">NaN</span>);</span><br><span class="line">      $add.<span class="title function_">add</span>(<span class="title class_">NaN</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>($add);<span class="comment">//NaN也只加入了一个</span></span><br></pre></td></tr></table></figure><h3 id="2-查-has-数据"><a href="#2-查-has-数据" class="headerlink" title="2.查:has(数据)"></a>2.查:has(数据)</h3><p> 判断set集合中是否存在查询的这个数据 返回值为boolean类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">var</span> $has = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($has.<span class="title function_">has</span>(<span class="number">1</span>));  <span class="comment">//true</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>($has.<span class="title function_">has</span>(<span class="title class_">NaN</span>)); <span class="comment">//true</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>($has.<span class="title function_">has</span>(+<span class="number">0</span>)); <span class="comment">//true</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>($has.<span class="title function_">has</span>(-<span class="number">0</span>)); <span class="comment">//true</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>($has.<span class="title function_">has</span>(<span class="number">6</span>)); <span class="comment">//true</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>($has.<span class="title function_">has</span>(<span class="number">9</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="3-删：delete-数据"><a href="#3-删：delete-数据" class="headerlink" title="3.删：delete(数据)"></a>3.删：delete(数据)</h3><p>对集合里面的数据进行匹配，匹配成功就删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $delete = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($delete.<span class="title function_">delete</span>(<span class="number">9</span>));  </span><br><span class="line"><span class="comment">//flase  表示没有找到9这个数据  所以删除失败  返回false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($delete.<span class="title function_">delete</span>(<span class="number">1</span>));  </span><br><span class="line"><span class="comment">//true  表示找到了1这个对应的数据  所以删除成功  返回true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($delete); <span class="comment">//&#123;2, 6, 5, 0, NaN&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-清空-clear"><a href="#4-清空-clear" class="headerlink" title="4.清空 clear()"></a>4.清空 clear()</h3><p>清空整个set集合，不需要传任何参数，clear方法是没有返回值的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">clear</span>()); <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">//set(0)&#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-size属性"><a href="#5-size属性" class="headerlink" title="5.size属性"></a>5.size属性</h3><p> 是获取set合集里面所有的元素个数，基本上是数组的长度类似</p><p> 但是 size只是可读性，不能重新赋值，如果重新赋值，不会起任何作用，也不会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">size</span>); <span class="number">0</span></span><br><span class="line">        s.<span class="property">size</span> = <span class="number">7</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">//set(0)&#123;&#125;</span></span><br></pre></td></tr></table></figure><p> 数组的长度 可以进行设置，设置过后同样改变数组元素，没有元素的值为空</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>, <span class="number">23</span>, <span class="number">332</span>];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>);  <span class="comment">//3</span></span><br><span class="line">        arr.<span class="property">length</span> = <span class="number">5</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);  <span class="comment">//[12,23,332,empty乘以2]</span></span><br></pre></td></tr></table></figure><h3 id="6-set集合的遍历"><a href="#6-set集合的遍历" class="headerlink" title="6.set集合的遍历"></a>6.set集合的遍历</h3><p>使用for-of进行遍历 返回的item是每一项的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="7-forEach方法"><a href="#7-forEach方法" class="headerlink" title="7.forEach方法"></a>7.forEach方法</h3><p>forEach方法是set集合的实例化方法，但是set集合没有下标，所以item和index都表示元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, s</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line"></span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><h3 id="8-filter方法"><a href="#8-filter方法" class="headerlink" title="8.filter方法"></a>8.filter方法</h3><p>返回值是一个新数组，用来检测数组中的元素是否符合某一条件，把符合条件的元素过滤出来</p><p>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item,index,self</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> item % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><p>例如，把一个Array中的空字符串删掉，可以这么写：</p><p>元素前后的空格需要遍历删除，这个只能删除空字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;  &#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s &amp;&amp; s.<span class="title function_">trim</span>(); </span><br><span class="line">    <span class="comment">// 注意：IE9以下的版本没有trim()方法</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>filter()接收的回调函数，其实可以有多个参数。<strong>通常</strong>我们仅使用<strong>第一个参数</strong>，表示<strong>Array的某个元素</strong>。回调函数还可以接收<strong>另外两个</strong>参数，表示<strong>元素的位置</strong>和<strong>数组本身</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item, index, self</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// 依次打印&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;//元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index);<span class="comment">// 依次打印0, 1, 2 //索引</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self); <span class="comment">// self就是变量arr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;aaa&quot;</span>];</span><br><span class="line">        <span class="keyword">var</span> arr2 =</span><br><span class="line">            arr1.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item,index,arr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item) == index;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">//[&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]</span></span><br></pre></td></tr></table></figure><h5 id="交集，并集，差集"><a href="#交集，并集，差集" class="headerlink" title="交集，并集，差集"></a>交集，并集，差集</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">19</span>, <span class="number">69</span>, <span class="number">67</span>, <span class="number">58</span>, <span class="number">26</span>, <span class="number">67</span>];</span><br><span class="line">        <span class="keyword">var</span> arr2 = [<span class="number">18</span>, <span class="number">79</span>, <span class="number">58</span>, <span class="number">99</span>, <span class="number">67</span>, <span class="number">79</span>, <span class="number">67</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并集</span></span><br><span class="line">        <span class="comment">// var arrs = arr1.concat(arr2);</span></span><br><span class="line">        <span class="comment">// var sss = new Set(arrs);</span></span><br><span class="line">        <span class="comment">// arrs = [...sss];</span></span><br><span class="line">        <span class="comment">// console.log(arrs);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> con = [...<span class="keyword">new</span> <span class="title class_">Set</span>([...arr1, ...arr2])];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(con);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//交集</span></span><br><span class="line">        <span class="comment">// var a1 = new Set(arr1);</span></span><br><span class="line">        <span class="comment">// var a2 = new Set(arr2);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// var a = [...a1, ...a2];</span></span><br><span class="line">        <span class="comment">// console.log(a);</span></span><br><span class="line">        <span class="comment">// var ssw = a.filter(function (item, index, arr) &#123;</span></span><br><span class="line">        <span class="comment">//     return arr.indexOf(item) != index;</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">        <span class="comment">// console.log(ssw);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> inter = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr1)].<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr2.<span class="title function_">indexOf</span>(item) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(inter);</span><br><span class="line">        <span class="keyword">var</span> inter2 = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr1)].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> arr2.<span class="title function_">indexOf</span>(item) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(inter2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//差集</span></span><br><span class="line">        <span class="keyword">var</span> arr3 = con.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item, index, arr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> inter.<span class="title function_">indexOf</span>(item) &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr3);</span><br></pre></td></tr></table></figure><h5 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get_primes</span>(<span class="params">arr</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> s = arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(x&lt;<span class="number">4</span>)<span class="keyword">return</span> x!=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">var</span> i=<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">for</span>(;i&lt;=x/<span class="number">2</span>;++i)</span><br><span class="line">   <span class="keyword">if</span>(x%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 测试:</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    x,</span><br><span class="line">    r,</span><br><span class="line">    arr = [];</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">r = <span class="title function_">get_primes</span>(arr);</span><br><span class="line"><span class="keyword">if</span> (r.<span class="title function_">toString</span>() === [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>].<span class="title function_">toString</span>()) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;测试通过!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;测试失败: &#x27;</span> + r.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ES6的Map基本用法"><a href="#ES6的Map基本用法" class="headerlink" title="ES6的Map基本用法"></a>ES6的Map基本用法</h2><p><strong>使用方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br></pre></td></tr></table></figure><p><strong>map的循环</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line"> map.<span class="title function_">set</span>(key, value);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(map);</span><br></pre></td></tr></table></figure><p>  &#x2F;&#x2F;set() 是给map集合设置键值对元素 参数1:键  参数2:值</p><p>  &#x2F;&#x2F;get() 是获取map集合中指定键的值</p><h4 id="1-has-查"><a href="#1-has-查" class="headerlink" title="1.has() 查"></a>1.has() 查</h4><p>判断指定键是否存在于map集合中 返回布尔类型的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&quot;boyfriend&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="2-delete-删"><a href="#2-delete-删" class="headerlink" title="2.delete() 删"></a>2.delete() 删</h4><p>删除map集合中指定键的键值对 返回布尔类型的值 能找到 就删除 返回true  否则返回false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">delete</span>(<span class="string">&quot;girlfriend&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">delete</span>(<span class="string">&quot;boyfriend&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="3-clear-清空"><a href="#3-clear-清空" class="headerlink" title="3.clear() 清空"></a>3.clear() 清空</h4><p> 清空集合中所有的元素 没有参数 没有返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">clear</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map);</span><br></pre></td></tr></table></figure><h4 id="4-map集合转换成数组"><a href="#4-map集合转换成数组" class="headerlink" title="4.map集合转换成数组"></a>4.map集合转换成数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [...map];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h4 id="5-map集合的遍历"><a href="#5-map集合的遍历" class="headerlink" title="5.map集合的遍历"></a>5.map集合的遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for-of方法遍历k </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="6-和结构赋值进行结合"><a href="#6-和结构赋值进行结合" class="headerlink" title="6.和结构赋值进行结合"></a>6.和结构赋值进行结合</h4><p>优点:取值方便</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [key,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-fotEach-遍历"><a href="#7-fotEach-遍历" class="headerlink" title="7.fotEach 遍历"></a>7.fotEach 遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value,key,self</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(self);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="函数处理"><a href="#函数处理" class="headerlink" title="函数处理"></a>函数处理</h2><h3 id="1-使用Promise解决异步编程"><a href="#1-使用Promise解决异步编程" class="headerlink" title="1.使用Promise解决异步编程"></a>1.使用Promise解决异步编程</h3><p>Promise是解决异步编程问题的一种方案</p><p>从语法上讲 promise是一个对象 通过这个对象 我们可以获取异步操作的信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> random = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(random);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (random &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&quot;响应成功&quot;</span> &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&quot;响应失败&quot;</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="调用promise的than方法"><a href="#调用promise的than方法" class="headerlink" title="调用promise的than方法"></a>调用promise的than方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br></pre></td></tr></table></figure><h3 id="2-使用Promise封装ajax"><a href="#2-使用Promise封装ajax" class="headerlink" title="2.使用Promise封装ajax"></a>2.使用Promise封装ajax</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toData</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">       <span class="comment">//声明一个数组 来装每一组的数据</span></span><br><span class="line">       <span class="keyword">var</span> arr = [];</span><br><span class="line">       <span class="keyword">if</span> (obj !== <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">               <span class="keyword">let</span> str = key + <span class="string">&quot;=&quot;</span> + obj[key];</span><br><span class="line">               arr.<span class="title function_">push</span>(str);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, rejevct</span>) &#123;</span><br><span class="line">           <span class="comment">//给ajax所需要的参数设置默认值</span></span><br><span class="line">           obj.<span class="property">type</span> = obj.<span class="property">type</span> || <span class="string">&quot;get&quot;</span>;</span><br><span class="line">           obj.<span class="property">async</span> = obj.<span class="property">async</span> || <span class="string">&quot;trie&quot;</span>;</span><br><span class="line">           obj.<span class="property">dataType</span> = obj.<span class="property">dataType</span> || <span class="string">&quot;json&quot;</span>;</span><br><span class="line">           obj.<span class="property">data</span> = ppbj.<span class="property">data</span> || <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//开始发送ajax请求</span></span><br><span class="line">           <span class="keyword">var</span> xhr;</span><br><span class="line">           <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span><br><span class="line">               xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//IE低版本的浏览器</span></span><br><span class="line">               xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHttp&quot;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 判断是post请求 还是get请求</span></span><br><span class="line">           <span class="keyword">if</span> (obj.<span class="property">type</span> === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">               xhr.<span class="title function_">open</span>(obj.<span class="property">type</span>, obj.<span class="property">url</span>, obj.<span class="property">async</span>);</span><br><span class="line">               <span class="comment">// 设置请求头</span></span><br><span class="line">               xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line"></span><br><span class="line">               xhr.<span class="title function_">send</span>(<span class="title function_">toData</span>(obj.<span class="property">data</span>));</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">var</span> url = obj.<span class="property">url</span> + <span class="string">&quot;?&quot;</span> + <span class="title function_">toData</span>(obj.<span class="property">data</span>);</span><br><span class="line">               xhr.<span class="title function_">open</span>(obj.<span class="property">type</span>, url, obj.<span class="property">async</span>);</span><br><span class="line">               xhr.<span class="title function_">send</span>();</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//处理响应体</span></span><br><span class="line">           xhr.<span class="property">onreadystatechamge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span> || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">                       <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>));</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="title function_">reject</span>(xhr.<span class="property">status</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-then和catch"><a href="#3-then和catch" class="headerlink" title="3.then和catch"></a>3.then和catch</h3><h4 id="1-Promise-prototype-then-方法"><a href="#1-Promise-prototype-then-方法" class="headerlink" title="1.Promise.prototype.then()方法"></a>1.Promise.prototype.then()方法</h4><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pro1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,rejevt</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1234</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        在<span class="title class_">Promise</span>对象  是同步的代码</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(pro1);</span><br><span class="line">        <span class="comment">//then方法是异步的</span></span><br><span class="line">        pro1.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p> **1.**如果当前的Promise对象是未决的 得到的Promise对象是被挂起的</p><p>​</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pro1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(pro1);<span class="comment">//已决状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> pro2 = pro1.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> data * <span class="number">3</span>,<span class="function"><span class="params">err</span>=&gt;</span>err*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">var</span> pro3 = pro2.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(pro2);<span class="comment">//未决状态</span></span><br><span class="line"></span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err * <span class="number">2</span>);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>  **2.**如果当前的Promise对象是已决的 那么 就会运行相应的后续函数</p><h4 id="2-Promise-prototype-catch-方法"><a href="#2-Promise-prototype-catch-方法" class="headerlink" title="2.Promise.prototype.catch()方法"></a>2.Promise.prototype.catch()方法</h4><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p><p>在未决状态的处理函数中 如果发生未捕获的错误 那么状态就会有pending 直接变成 rejected状态 并且可以被catch捕获</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pro = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">          <span class="comment">// try&#123;</span></span><br><span class="line">          <span class="comment">//     throw new Error(&quot;123&quot;);</span></span><br><span class="line">          <span class="comment">// &#125;catch(e)&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">          <span class="title function_">resolve</span>(<span class="number">12</span>);</span><br><span class="line">          <span class="title function_">reject</span>(<span class="number">34</span>);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-Promise的方法"><a href="#4-Promise的方法" class="headerlink" title="4.Promise的方法"></a>4.Promise的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&quot;我是第一个请求&quot;</span>);</span><br><span class="line">            &#125;,<span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&quot;我是第二个请求&quot;</span>);</span><br><span class="line">            &#125;,<span class="number">3000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> r3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&quot;我是第三个请求&quot;</span>);</span><br><span class="line">            &#125;,<span class="number">3000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> r4 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">&quot;我是第四个请求&quot;</span>);</span><br><span class="line">            &#125;,<span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h4><p>请求同时发送出去 但是要等到最后一个请求返回以后 统一处理数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([r1,r2,r3,r4]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="race-方法"><a href="#race-方法" class="headerlink" title="race 方法"></a>race 方法</h4><p>请求同时发送出去 谁先回来 就是用谁的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([r1,r2,r3,r4]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h3 id="5-async和await"><a href="#5-async和await" class="headerlink" title="5.async和await"></a>5.async和await</h3><h4 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h4><p> async 作用 简化函数返回值中promise对象的创建</p><p>一般情况下 async写在函数的最前面 被修饰的函数的返回值 一定是promise对象</p><p><strong>因为<code>await</code>会阻塞代码的执行。而解决这个弊端的手段就是<code>async</code>声明。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//throw 13;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只有在某些特殊情况下  才会返回手动返回一个promise对象</span></span><br><span class="line">            <span class="comment">// return new Promise((resolve,reject)=&gt;&#123;</span></span><br><span class="line">            <span class="comment">//     resolve(20);</span></span><br><span class="line">            <span class="comment">// &#125;)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">test</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">test</span>());</span><br><span class="line"><span class="comment">//其实之所以async声明能解决await的阻塞问题，就是因为async声明将函数作了一层promise包装，这样内部的异步操作其实就是由pending转为resolve或者reject的过程。这样函数本身就能够随意调用，函数内部的await也不会再影响到函数外部的代码执行。</span></span><br></pre></td></tr></table></figure><h4 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h4><p><code>await</code>的意思就是<strong>等待</strong>。它后面可以跟一个表达式。如果是值(如字符串、数字、普通对象等等)的话，返回值就是本身的值。</p><p>不过最常用的是后面跟一个promise<code>对象。</code>await<code>会等待这个</code>promise<code>的状态由</code>pending<code>转为</code>fulfilled<code>或者</code>rejected&#96;。<strong>在此期间它会阻塞，延迟执行await语句后面的语句。</strong></p><p>如果<code>promise</code>对象的结果是<code>resolve</code>，它会将<code>resolve</code>的值，作为<code>await</code>表达式的运算结果。</p><p>​其实<code>await</code>与<code>async</code>本身就是<code>promise</code>化编程的一种语法糖。对比一下两种写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步promise化的函数--模拟请求后端接口</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFn</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve console&#x27;</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;resolve return&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&#x27;reject return&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise</span></span><br><span class="line"><span class="title function_">asyncFn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// await</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">await</span> <span class="title function_">asyncFn</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有第二次请求的话，promise需要在then方法继续调用，再用then接受，过多的嵌套依然会增加阅读难度。而await async只需要像写同步代码一样继续书写就可以，它是解决异步编程回调地狱的终极手段。</span></span><br></pre></td></tr></table></figure><h3 id="6-extends关键字"><a href="#6-extends关键字" class="headerlink" title="6.extends关键字"></a>6.extends关键字</h3><p><strong>使用class关键字实现继承  需要使用extends关键字</strong></p><p>**<code>extends</code>**关键字用于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class">类声明</a>或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/class">类表达式</a>中，以创建一个类，该类是另一个类的子类。</p><p><strong>语法:</strong></p><p>class 父类 { }  </p><p>class 子类 extends 父类 { }</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">            <span class="title function_">constructor</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">work</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;修身养性&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">            <span class="title function_">constructor</span>(<span class="params">name,age,type</span>)&#123;</span><br><span class="line">                <span class="variable language_">super</span>(name,age);</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">type</span> = type;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;喻文波&quot;</span>,<span class="number">19</span>,<span class="string">&quot;职业选手&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">        s.<span class="title function_">work</span>();</span><br></pre></td></tr></table></figure><h3 id="7-generator和yield表达式"><a href="#7-generator和yield表达式" class="headerlink" title="7.generator和yield表达式"></a>7.generator和yield表达式</h3><h4 id="1-什么是generator函数"><a href="#1-什么是generator函数" class="headerlink" title="1.什么是generator函数?"></a>1.什么是generator函数?</h4><p>generator函数其实就是一个状态机 里面封装了多个状态 通过调用next方法返回当前遍历的值</p><p>generator函数实际上是一个iteration生成器</p><p>作为普通函数 进行调用 name函数就会从头到尾执行一遍 除非遇到return就停止</p><h4 id="2-generator语法"><a href="#2-generator语法" class="headerlink" title="2.generator语法"></a>2.generator语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(); </span><br><span class="line"><span class="comment">// &quot;Generator &#123; &#125;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-generator函数的特性"><a href="#3-generator函数的特性" class="headerlink" title="3.generator函数的特性:"></a>3.generator函数的特性:</h4><p>1.generator函数是分步执行的 yield+”值”; 表达式是函数暂停的标志 而调用next方法可以恢复函数的执行</p><p>2.generator函数在function关键字和函数名之间 有一个* 通常情况下 挨着function关键字写</p><p>3.yield关键字定义了函数内部不同的状态</p><p>4.generator函数在调用的时候 没有执行函数体代码 只是返回了一个iterator对象 只有调用next方法才能遍历它内部的每一个状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">love</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">yield</span> <span class="string">&quot;他们恋爱了&quot;</span>;</span><br><span class="line">           <span class="keyword">yield</span> <span class="string">&quot;他们结婚了&quot;</span>;</span><br><span class="line">           <span class="keyword">yield</span> <span class="string">&quot;他们离婚了&quot;</span>;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;tragic ending&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">love</span>());</span><br><span class="line">       <span class="keyword">var</span> lv = <span class="title function_">love</span>();</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(lv.<span class="title function_">next</span>());</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(lv.<span class="title function_">next</span>());</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(lv.<span class="title function_">next</span>());</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(lv.<span class="title function_">next</span>());</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(lv.<span class="title function_">next</span>());</span><br></pre></td></tr></table></figure><h4 id="4-next被调用之后的运行逻辑"><a href="#4-next被调用之后的运行逻辑" class="headerlink" title="4.next被调用之后的运行逻辑:"></a>4.next被调用之后的运行逻辑:</h4><p>​    1.当函数调用之后 遇到 yield关键字 就会暂停运行后面的代码 调用next方法之后 紧跟着yield关键字后面的值就会作为返回值返回</p><p>​    2.当我们再次调用next方法的时候 就会从当前的位置继续往下走 直到遇见下一个yield</p><p>​    3.运行到最后 如果没有再遇到 yield关键字 就会一直往下运行 直到遇见return关键字 就停止执行 返回值就是return后面的值 状态值为true</p><p>​    4.如果没有return 那么返回值是undefined done的值为true</p><h4 id="5-yield表达式"><a href="#5-yield表达式" class="headerlink" title="5.yield表达式"></a>5.yield表达式</h4><p>只能在generator函数里面用 在其他的使用 会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>);</span><br><span class="line">           <span class="keyword">yield</span> <span class="number">12</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="title function_">test</span>();</span><br></pre></td></tr></table></figure><h4 id="6-yield-表达式的作用"><a href="#6-yield-表达式的作用" class="headerlink" title="6.yield*表达式的作用"></a>6.yield*表达式的作用</h4><p>如果在一个generator函数里面去调用另一个generator函数 使用普通的调用方法是不起作用 ，必须使用 yield*表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">test1</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="keyword">yield</span> <span class="string">&quot;111&quot;</span>;</span><br><span class="line">           <span class="keyword">yield</span> <span class="string">&quot;222&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">function</span>* <span class="title function_">test2</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">yield</span>* <span class="title function_">test1</span>();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">yield</span> <span class="string">&quot;333&quot;</span>;</span><br><span class="line">           <span class="keyword">yield</span> <span class="string">&quot;444&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> test = <span class="title function_">test2</span>();</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="title function_">next</span>());</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="title function_">next</span>());</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="title function_">next</span>());</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="title function_">next</span>());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨端技术</title>
      <link href="/2022/10/14/%E8%B7%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/10/14/%E8%B7%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="“不可陷之楯与无不陷之矛，不可同世而立”-————-《韩非子》"><a href="#“不可陷之楯与无不陷之矛，不可同世而立”-————-《韩非子》" class="headerlink" title="“不可陷之楯与无不陷之矛，不可同世而立” ———— 《韩非子》"></a>“不可陷之楯与无不陷之矛，不可同世而立” ———— 《韩非子》</h1>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨端技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多样化</title>
      <link href="/2022/10/14/%E5%A4%9A%E6%A0%B7%E5%8C%96/"/>
      <url>/2022/10/14/%E5%A4%9A%E6%A0%B7%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="“乱花渐欲迷人眼，浅草才能没马蹄”-————-钱塘湖春行"><a href="#“乱花渐欲迷人眼，浅草才能没马蹄”-————-钱塘湖春行" class="headerlink" title="“乱花渐欲迷人眼，浅草才能没马蹄” ———— 钱塘湖春行"></a>“乱花渐欲迷人眼，浅草才能没马蹄” ———— 钱塘湖春行</h1>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多样化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端体验</title>
      <link href="/2022/10/14/%E5%89%8D%E7%AB%AF%E4%BD%93%E9%AA%8C/"/>
      <url>/2022/10/14/%E5%89%8D%E7%AB%AF%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="“不忘初心，方得始终”-————-《华严经》"><a href="#“不忘初心，方得始终”-————-《华严经》" class="headerlink" title="“不忘初心，方得始终” ———— 《华严经》"></a>“不忘初心，方得始终” ———— 《华严经》</h1>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言框架</title>
      <link href="/2022/10/14/%E8%AF%AD%E8%A8%80%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/10/14/%E8%AF%AD%E8%A8%80%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="“形而上者谓之道，形而下者谓之器”-————-《易经·系辞》"><a href="#“形而上者谓之道，形而下者谓之器”-————-《易经·系辞》" class="headerlink" title="“形而上者谓之道，形而下者谓之器” ———— 《易经·系辞》"></a>“形而上者谓之道，形而下者谓之器” ———— 《易经·系辞》</h1>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低代码</title>
      <link href="/2022/10/14/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/10/14/%E4%BD%8E%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="“旧时王谢堂前燕，飞入寻常百姓家”-————-《乌衣巷》"><a href="#“旧时王谢堂前燕，飞入寻常百姓家”-————-《乌衣巷》" class="headerlink" title="“旧时王谢堂前燕，飞入寻常百姓家” ———— 《乌衣巷》"></a>“旧时王谢堂前燕，飞入寻常百姓家” ———— 《乌衣巷》</h1>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 低代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node/Serverless</title>
      <link href="/2022/10/14/Node-Serverless/"/>
      <url>/2022/10/14/Node-Serverless/</url>
      
        <content type="html"><![CDATA[<h1 id="“行而不辍，未来可期”-————-《荀子·修身》"><a href="#“行而不辍，未来可期”-————-《荀子·修身》" class="headerlink" title="“行而不辍，未来可期” ———— 《荀子·修身》"></a>“行而不辍，未来可期” ———— 《荀子·修身》</h1>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node/Serverless </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
